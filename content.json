{"pages":[],"posts":[{"title":"해시함수에 대하여","text":"해시함수란해시함수는 임의의 길이의 데이터를 입력받아 일정한 길이의 비트열로 반환 시켜주는 함수이다. 입력값의 길이가 달라도 출력값은 언제나 고정된 길이로 반환한다. 동일한 값이 입력되면 언제나 동일한 출력값을 보장한다. 암호화 해시 함수란암호화 해시 함수 는 이 해시함수의 부분집합으로 역상저항성과 제2역상저항성 그리고 충돌저항성을 가지고 있어 암호화에 활용될 수 있는 경우를 의미한다. 암호화 해시 함수의 특성과 효과들 역상저항성은 입력값 A에 의해 B가 출력되었다면, 출력된 B값만 주어졌을 때 입력값인 A값을 찾는 것이 계산적으로 불가능함을 의미한다. 제2역상저항성 은 입력값 A와 출력값 B가 모두 주어졌을 때, 똑같은 B를 반환하는 A2 를 찾아내거나 만들어내는 것이 계산적으로 불가능함을 의미한다. 단방향 암호화라고도 하는데 양방향 암호화가 A를 B로 암호화하고 다시 B를 A로 복호화하여 원본 내용을 확인할 수 있다면, 단방향 암호화는 A로 만들어진 B를 가지고 다시 A로 역산할 수 없다. 충돌저항성은 똑같은 B라는 출력값이 나오는 X가 단일하지 않고 중복이 되는 또 다른 Xn을 발견하는 것이 계산적으로 어려운 성질을 의미한다. 충돌저항성은 제2역상저항성의 외부효과(부수효과, Side effect) 이자 부분집합 이다. 압축효과 암호화 해시 함수가 반환하는 일정한 길이의 작은 해시값만으로 크기가 거대한 데이터의 무결성을 보장할 수 있는 외부효과를 의미한다. 예를 들어 SHA-256의 경우 100GB의 파일도 단 256bit의 해시값으로 그 내용의 무결성을 보장할 수 있다. 눈사태 효과눈사태 효과 란 입력값의 아주 작은 변화로도 결과값이 전혀 다르게 도출되는 효과를 의미한다.입력값에 점 하나만 추가되어도 전혀 다른 출력값이 출력된다. 또한 변경되는 부분에 있어 어떠한 규칙성도 찾을 수 없다. 예시아래는 SHA1 함수를 이용해 비슷한 문자열을 암호화한 결과값들이다. “주영재” -&gt; DDB0ED48A84B6C328E50B3BFB3D15364C669C3A6 “주영째” -&gt; 1C2FC56A4172A9B6D5C3C20309A46C01896D3194 “주형재” -&gt; 1DA926EEF1EF8533F57A45124871F8550A278EA9 용도 파일의 Checksum(검사합)을 구한다. SuperVaccine.exe 이라는 가상의 컴퓨터 바이러스 백신 프로그램을 다운로드 받았다고 가정해보자. 만약에 어떤 블랙 해커가 해당 백신 사이트를 해킹해서 설치파일을 비슷한 모양새로 동작하지만 오히려 치명적인 바이러스가 포함된 파일로 변조를 했다면 .. ? 혹은 다운로드 프로그램의 문제나 보관 방식의 문제로 인해 어떤 파일의 내용에 부분적인 결손이 의심된다면 … ? 우선 전자의 경우 블랙 해커는 제2역상저항성 으로 인해 똑같은 Checksum을 가지는 바이러스 파일을 만들 수 없다. 눈사태효과로 인해 아주 미세한 결손이나 위변조가 발생되어도 Checksum 값이 완전히 달라지게 된다. 이 때 내가 받은 설치파일이 올바른 파일이 맞는지 또 제대로 손실없이 받아진 파일이 맞는지 확인하기 위해 해당 설치파일의 데이터를 입력값으로 하여 생성된 해시값을 공식 홈페이지나 다른 공인된 인터넷 페이지에 공개된 해시값과 비교하여 검증할 수 있다. 이상이 없는 파일이라면 내가 받은 파일을 같은 함수로 검증했을 때, 공개된 해시값과 동일한 해시값이 출력될 것이기 때문이다. 마치 해시값을 어떤 데이터의 지문Fingerprint 처럼 활용하는 경우이다. 암호를 저장한다 회원가입 기능을 제공하는 인터넷 서비스를 만든다 가정했을 때 가입된 회원들의 암호를 날 것 그대로 저장하면 안된다. 사용자 암호의 원문이 아닌 해시 암호화한 값을 DB에 저장해놓고, 이후 회원이 로그인을 시도할 때 입력한 암호를 동일한 해시함수로 암호화하여 DB의 해시값과 비교한다. 이 경우 원본 암호를 서버에 기록하지 않고도 유저들은 불편함 없이 평소에 사용하던 암호를 로그인에 활용할 수 있게 된다. 또한, 우리의 가상 서비스가 해킹이 되어 회원들의 DB가 유출이 되더라도 해커는 역상저항성으로 인해 회원들의 진짜 암호를 알아낼 수 없다. 해시테이블에서의 활용. 어떤 데이터의 목록에서 특정 데이터를 조회한다고 생각해보자. 일반적인 방법으로는 데이터를 첫번째 순서부터 하나하나 대조해보거나 특정한 규칙에 따라 순차적으로 각 요소들을 대조하여 특정한 값을 찾아내는 방법이 있다. 해시함수의 충돌저항성을 활용해 데이터를 저장할 때 해당 데이터의 해시값을 별도로 원하는 데이터를 찾아낼 수 있는 ‘키값’ 으로 활용한다면? 각 데이터의 전체값을 비교하지 않고도 일정 길이의 해시값을 이용해 원하는 데이터를 찾아낼 수 있다. 별도의 탐색절차 없이 그 즉시 원하는 데이터를 추출할 수 있으므로 궁극의 탐색 알고리즘이다. 블록체인에서 해시함수의 쓰임새아래의 내용은 필자가 관련 분야의 전문가가 아님을 감안하고 읽어주면 감사하겠다. 블록체인을 아주 높은 수준에서 추상화해서 다음 블록이 그 이전 블록에 체인을 걸고 또 다음 블록이 그 이전 블록으로 체인을 걸고.. 이런 식으로 기차들 처럼 모든 블록들이 선형으로 줄줄이 이어져 있는 모양새라고 생각해보자. 앞선 블록들은 어떤 목적을 위해 포함하고 있는 내용들이 절대 변경되서는 안된다라고 규칙을 정했을 때..(코인의 과거 거래 이력은 상식적으로 당연히 변동이 있어서는 안된다) 이를 실현하기 위해 각 블록들은 자기 자신의 ‘내용’을 해싱해서 해시값을 갖고(블록헤더라고 칭해보자), 자기자신의 해시값을 갖고 있음은 물론 그 이전 블록의 해시값을 참조하게 된다.(이전 블록의 해시값을 다음 블록이 참조한다라는 것을 앞서 이야기한 체인을 거는 비유의 구체적인 실체이다) 혹시라도 어떤 나쁜 사람이 자신의 이익을 위해 가거 블록의 내용을 변경하게 된다면 그 블록의 해시값이 변경되고(눈사태효과, 쇄도효과에 의해)..그 이후 블록은 이전 블록을 해시값으로 참조하고 있기 때문에 연결이 단선되고, 만약에 그 나쁜 사람이 변경된 내용을 거래에 참여하는 모든 사람들에게 인정받고자 한다면 그 이후 모든 블록들의 해시값을 전부 다시 만들어 내야 될 것이다. 위 설명에서 블록체인에서 해시함수는 각 블록을 연결시키는 체인의 용도로써, 또 과거 이력의 변경을 감지하는 역할로써 사용한다라고 정리해볼 수 있을 것이다. 블록체인에서 해시함수의 또 다른 용도에 대해 설명해보겠다. 비트코인과 관련하여 ‘채굴’이라는 용어를 많이 들어봤을 것인데, ‘채굴’을 조금 더 전문적인 용어로 작업증명(Proof of work)이라고 하고, 그 진짜 의미는 ‘해시함수를 활용한 어떤 퍼즐을 풀어내는 일’이다. 해시함수를 이용해 의도적으로 계산적 소모량을 유발하는 퍼즐을 만들어 이 퍼즐을 풀어냈을 때 작업증명을 해냈다 혹은 채굴에 성공했다라고 한다. 그 과정을 대략적으로 설명하자면,우선 해당 블록의 거래내역을 참조한 해시값(정확한 용어로 Merkle root 해시값), 이전 블록의 블록해시, 블록 생성시각 등등 고정된 데이터들의 집합이 재료로 주어지고, 이 변경될 수 없는 데이터에 nonce 라는 이름의 Salt(해시값을 바꾸기 위해 첨가하는 임의의 숫자) 를 계속 바꿔 더해가며 특정한 조건의 SHA256 해시값을 찾는 과정이라고 보면된다. 이 조건이라는 것은 nonce를 계속 증가시켜가며 만들어낸 해시값이 00000000A84B6C328E50B3BFB3D15364C669C3A6 와 같이 앞에 0이 몇 개 이상 있어야 된다 같은 것이다. 확률적으로 (1/16)n이 될텐데,암호화 해시함수를 통해 특정 해시값을 만들어내기 위해선 어떠한 지적 추론도 불가능하고 오로지 컴퓨팅 파워를 이용한 수많은 시행착오를 반복할 수 밖에 없다는 특징을 응용한 것이다. 앞서 체인을 만드는 용도로써 해시함수를 설명할 때, 과거 내용을 변조하려는 공격자의 예를 들었는데.. 이 공격자가 왜 공격을 실패할 수 밖에 없는지..해시퍼즐을 통해 유발되는 계산적 소모량이 그 정답이 된다.변조하려는 블록부터 시작하여 이후 모든 블록의 해시값을 계산해야되고 그 이후 새롭게 생성되는 블록들의 해시값도 전부 다 다시 계산해야 한다면..어떤 누가 쉽게 공격을 하려는 의지를 갖을 것이며, 그 공격이 성공할 수 있을까? 취약한 부분과 충돌쌍y = 2x 라는 함수를 가정했을 때 y가 A인 x를 찾아내는 과정을 역산이라고 한다. y가 12라면, 12 = 2x 12 / 2 = x 6 = x 해시함수는 그 구현내용이 공개되어 있음에도 이러한 과정으로 원본값을 알아내는 역산이 계산상 불가능하다. 하지만 역산 외의 방법으로도 B를 반환하는 An에 대해 탐색할 수 있는 다양한 방법들이 존재하는데 예를 들자면, 해당 해시함수에 의해 도출될 수 있는 방대한 경우의 수를 기록해 사전과 같은 형태로 만들어둔 후 해당 사전에서 A값을 찾아내어 대조해보는 방식(Rainbow attack) 이나, 반환값 B가 나오는 A 혹은 A2를 찾기 위해 임의의 경우의 수를 f(x)의 x에 무차별적으로 대입하여 찾아내는 방법(무차별 대입법, Brute-force attack)이 있을 수 있다. 단순 무식한 방법처럼 보일 수 있으나 컴퓨터는 이러한 단순 작업을 불평없이 수억번 수백억번 반복 수행하는데 특화된 기계이다. 또한, 컴퓨팅 파워가 나날이 발전하고 해시함수 연산을 위한 주문형 반도체가 등장하면서 현재의 암호화 해시 함수는 미래에 보안상 완결성을 상실할 가능성을 충분하게 가지고 있다. 일례로 1977년에 개발된 어떤 암호화 함수(RSA-129)의 개발자(Ronald Rivest)는 자신의 함수로 암호화된 메시지가 해독되는데 4경년이 걸릴 것으로 자신있게 예상했으나, 불과 17년 만인 1994년에 해독이 되어버린 사례가 있다. 더 가까운 과거의 사례로는 MD5 라는 암호화 해시 함수의 예를 들 수 있는데, 현재 MD5 해시값을 복호화하는 인터넷 사이트를 구글링만으로 쉽게 찾아볼 수 있는가 하면, MD5 Decryption - (MD5에 대한 Rainbow attack 의 예시) 심지어 서로 다른 문자열을 출력하는 두 개의 프로그램이 각각 똑같은 MD5 해시값을 갖는 경우도 발견되어 있다. MD5 Collision Demo 2011년까지 미국 표준으로 자리 잡았던 SHA1의 경우에도 충돌쌍(똑같은 해시값을 반환하는 서로 다른 데이터의 쌍) 이 아래와 같이 발견된 예시가 있다.해당 페이지에서는 동일한 SHA1 체크섬을 가진 두 개의 다른 PDF를 예시로 들고 있다. SHA1 충돌쌍 예시 생각해보면 입력값의 길이가 출력값의 길이보다 길어질 수 있다면 출력값의 충돌은 필연적으로 발생할 수 밖에 없기도 하다. 즉, 충돌쌍을 발견함에 있어서 충돌되는(중복되는) 경우가 확률적으로 아주 희소할지 몰라도, 무조건 하나 이상은 100%의 확률로 존재할 수 있다. (비둘기집 원리) 생일 역설 Birthday Paradox역설이란 보통 일반적인 생각에 반대되는 이론이나 말을 뜻한다. 일반적인 상식으로 당연히 A 가 맞다고 생각해왔는데 과학적으로 검증해보니 사실은 전혀 엉뚱한 B 가 진실인 경우들이 있다. 이 생일 역설 역시 그런한 경우인데, 이 역설은 처음 아래의 질문에서 출발한다. “n명의 사람이 임의로 모였을 때 우연히 생일이 중복되는 사람이 두 명 이상 있을 확률은 얼마나 될까?“ 일단 1년은 365일 이므로 366명이 모이면 비둘기집 원리에 따라 100% 최소 한 쌍은 생일이 중복될 것이 분명하다. 이렇게 생각해보자당신은 방송국 PD이다.세간에 유명한 “생일이 같은 사람은 비슷한 성격을 갖는다” 라는 속설에 대한 실험카메라 프로그램을 만들고자 한다. 그래서 생일이 같은 사람을 찾아야 하는데,문득 그런 사람들을 찾자고 (비둘기집 원리에 따라)366명이나 인터뷰를 해야되나라는 생각이 드니 눈 앞이 아득해지기 시작한다. 파일럿 프로그램이라 주어진 시간적, 경제적 자원이 많지 않기 때문이다. 그렇다고 좋은 기획을 날리기는 싫어서 울며 겨자먹기식으로 밖으로 나가 사람들을 인터뷰하는데 겨우 51명째에 벌써 생일이 같은 두 사람을 찾아내 버렸다. 당신은 속으로 생각한다. “이거 정말 운이 좋구만! 우리 프로그램이 잘 되려는 징조인가보다!“ 과연 그럴까과연 당신은 정말 기가 막히게 운이 좋았던 것일까? 사실은 아니다. 왜냐하면 사실 임의로 모인 50명의 사람들 중에서 생일이 중복되는 사람을 한 쌍 이상 찾아낼 확률이 무려 97% 이상 되었기 때문이다. 이번엔 100% 가까운 확률까지는 필요 없으니 그냥 두 번 조사했을 때 한 번만 나와도 되게끔 50% 정도로만 목표를 낮춰보겠다고 하자. 이 때 필요한 인원수를 계산하면 놀랍게도 그 수는 23명으로 파격적으로 줄어들게 된다. 이렇듯 확률의 목표값을 활용 가능한 범위내로 아주 약간 낮춤으로써 중복된 값을 찾아내는 비용을 파격적으로 낮출 수 있다는 점이 이 생일 역설의 골자가 되는 내용이다. 생일은 불과 365가지의 경우의 수를 가진다.하지만 해시 함수의 영역에서는 2126 같은 엄청난 크기의 경우의 수를 갖게 되는데,이 안에서 n개의 임의의 서로 다른 데이터를 모아 중복되는 경우를 찾는 일은 실로 엄청난 컴퓨팅 비용이 필요하게 될 것이고 이는 경제적인 비용 문제로 이어질 것이다.(충돌쌍을 찾는다고 한다, 위에서 언급한 생일찾기와 닮아있다) 하지만 이 생일역설이 해시함수의 충돌쌍을 찾는 일에도 적용된다면 생각보다 적은 비용을 가지고도 충돌쌍을 찾는 일을 할 수 있을 것이다. 실제로 충돌쌍을 찾는 확률을 50%로 맞추면 2(n/2) 의 표본만 있으면 된다고 한다. 출력값의 길이가 210(1024) 라는 암호화 해시함수가 있다고 가정했을 때, 25(32)회의 무차별 대입을 통해 무려 50%의 확률로 충돌쌍을 찾아낼 수 있게되는 것이다. 경제성이 없어 포기할 수도 있었던 일을 생일 역설을 통해 다시 경제성이 있는 일로 판단할 수 있게 된 것이다. 그럼에도 불구하고확률적으로 n 비트의 출력값을 가지는 해시함수의 경우 2(n/2) 가지의 입력값을 조사할 경우 충돌쌍을 발견할 확률이 50% 정도가 된다고 했다. (엄밀히 말하면 이보다 조금 더 많은 가짓수가 필요) 128bit의 출력값을 가지는 MD5의 경우 약 264 의 서로 다른 데이터를 만들어 무차별 대입하는 공격을 시도하면 50%의 확률로 1개 이상의 충돌쌍을 발견할 수 있다는 이야기이다. 264 가 얼마나 많은 경우의 수인지 짐작 어려울 것 같아 이를 10진수로 표현하면 아래와 같음을 참고하기 바란다. 18,446,744,073,709,551,617 개의 경우의 수를 가진다. 차수가 1씩 늘어날 때 위 숫자에 곱하기 2씩 해야되는 것이다. 당연하게도 출력값의 길이가 길어질 수록 경우의 수는 무차별적으로 증가한다. 필자가 위 생일 역설을 참고해 n개의 데이터가 m종류의 해시값에 대해 하나 이상의 중복값을 가질 확률을 계산해 보았더니, 128bit의 출력값을 가지는 해시함수의 경우 백억번이라는 어마무시한 분량의 무차별 대입 공격법을 시도해도 그 확률은 0에 수렴했다. (파이썬으로 구현해 pypy3로 돌렸다. 구현내용은 너무 단순무식 + 허접하여 차마 공개하지 못 하겠다 ㅠㅠ) 64bit의 출력값을 가지는 해시함수의 경우에도 일억번의 무차별 대입을 가정했을 때, 그 확률은 약 0.00027101407375584863 로 계산되었다. 앞서서 구글에서 SHA1 의 충돌쌍을 발견한 경우를 간단히 링크로 소개했는데, 그 결과를 도출해내는데 있어 약 9경번의 연산이 필요했으며, 수억원의 가치에 상응하는 경제적 비용이 필요했다고 한다. (SHA1은 160bit의 결과값을 가진다. 가성비가 0에 수렴한다는 이야기) 이러한 이유로 전문가들이 충돌쌍이 하나가 발견되었던 어쨌던 실제 응용 환경에 적용할만한 공격은 발견되지 않았다..라고 하는 것 같다. 고로, 일상적인 경우.. 그러니까 뭐 인덱스로 사용한다거나 체크섬 생성 용도로 이용하는데 있어서는 대충 SHA1 이상 아무 해시함수나 사용해도 전혀 무리가 없다는 이야기 정도로 결론 지으면 될 것 같다. 종류와 선택우선 보안성을 고려한 선택을 할 수 있다. 나와 사용자의 암호를 암호화하는데 사용할 해시함수는 앞으로도 우리의 소중한 암호들을 오랜 기간 지켜줄 수 있는 녀석으로 고르는 것이 현명할 것이기 때문이다. 앞서 설명한 MD5 함수는 매우 취약한 함수로 분류되어 해시테이블의 인덱스로 사용하거나 파일의 Checksum 생성 등의 한정된 용도를 제외한 사용자 암호 보존 용도의 사용을 권하지 않고 있다. (물론 비밀번호 생성이나 변경시 임의의 난수값을 붙여서 함께 해싱하는 방법으로 Rainbow attack 등 공격을 예방할 수 있기도 하다.입력값 A에 별도의 의미없는 난수값 @ 를 붙여서 해싱을 하면 A일 때와는 전혀 다른 결과값이 나온다. 이를 소금치기(Adding Salt) 라고 하고 위 경우에서 @를 소금(Salt) 이라고 한다.이 때 이 난수값은 해싱된 비밀번호와 마찬가지로 별도 보관된다.) 또한, 해시함수는 그 용도와 사용방법에 따라서도 서로 다른 것을 선택할 수 있다. 완벽에 가까운 역상저항성과 충돌저항성이 필요하지 않으며 단순 파일 체크섬 생성 등의 용도로만 필요한 경우 MD5나 SHA-1같은 것을 선택할 수도 있고, 무차별 대입공격 등을 예방하기 위해 한 번의 연산에 다소간의 시간이 소요되는 함수를 일부러 선택할 수도 있으며,(0.2초의 시간이 걸린다고 했을 때 사람 입장에서는 찰나의 순간일지 몰라도 수많은 경우의 수를 반복해서 대입해야 하는 공격 프로그램 입장에서는 엄청난 시간적 자원의 소모를 불러 일으킨다.) 한번에 많은 양의 해시값을 만들어야 내는 경우 혹은 하나의 입력값에 일부러 여러번의 재귀 연산을 해야되는 경우에는 속도가 빠른 함수를 골라야될 필요가 있다. 세상에는 다양한 종류의 암호화 해시 함수가 존재한다. 그중에서도 가장 대표적인 것은 단연 SHA(Secure Hash Algorithm) 함수군이며,SHA 함수군은 NSA(미국 국가 안보국)에서 SHA-0이 1993년에 처음 개발되었다. SHA함수군은 다시 또 세대별로 SHA-0, SHA-1, SHA-2, SHA-3 으로 나뉘고,SHA-2 함수군은 다시 다이제스트의 길이에 따라 SHA-256, SHA-512 등으로 나뉜다. SHA-256은 256bit의 다이제스트 길이를, SHA-512는 512bit의 다이제스트 길이를 갖는 함수로써 보통 다이제스트 길이가 길수록(출력값의 경우의 수가 많을수록) 암호화 함수로써 안정성이 높다고 본다. 잡설이 길었지만.. 결론은 용두사미..SHA2 함수군은 2002년에 개발되었으며 그냥 일반적으로 널리 사용된다. SHA-256 부터는 우리가 사용하는 입력값의 가짓수를 수억개 단위로 놓고 보아도, 충돌값이 나올 확률은 그냥 지구 대멸종을 야기할 소행성의 충돌 확률 보다도 더 낮다고 생각하면 되겠다. 결론적으로 일반적인 용도로는 그냥 SHA2 함수군을 사용하고, 보안에 정말 장기적인 관점에서 각별히 신경을 써야 하는 주체라면 SHA3 혹은 잘 설계된 자체 함수를 사용하면 된다. LSH 국산 해시 암호화 함수여담이지만, 국내에도 NSR이라는 기관에서 개발된 토종 국산신토불이 암호화 해시 함수가 있다. LSH(Lightweight Secure Hash) 자세한 구현 방법과 C, Java, Python 으로 작성된 소스코드도 제공하니 관심있으신 분들은 살펴보시면 좋을 것 같다. 향후 대한민국의 표준화된 해시 함수로써 자리매김할 가능성이 농후하다.","link":"/2019/08/11/ETC/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98%EC%97%90_%EB%8C%80%ED%95%98%EC%97%AC/"},{"title":"단락평가, 지름길 평가 (Short-circuit evaluation)","text":"자바스크립트의 논리연산자를 기본 용도인 참/거짓의 판단을 위해 사용하는 것이 아닌, 조건문을 대체해 사용하는 일종의 문법 설탕 이라고 볼 수 있다. 기본원리단락평가는 결국 조건연산자가 가진 아래의 두가지 특성을 응용한 것이다. 조건연산자의 좌결합성and연산자(&amp;&amp;)와 or연산자(||) 모두 좌결합성을 가진다.즉, 피연산자의 평가순서가 왼쪽부터 오른쪽 순으로 진행이 된다. 조건연산자의 평가결과조건연산자는 Boolean 값을 반환하지 않는다.최종적으로 평가된 피연산자의 평가결과를 반환한다. &amp;&amp; - andand 연산자의 경우 앞에 위치한 피연산자의 평가결과가 Falsy값일 경우굳이 이후의 피연산자를 평가하지 않아도 false가 되기에&amp;&amp; 연산자는 false로 평가된 피연산자 이후의 피연산자를 평가하지 않는다. 역으로 생각해보면 and 연산자는 앞에 위치한 피연산자의 평가결과가 Truthy값 이어야만,뒤쪽의 피연산자를 평가하여 그 결과를 반환한다는 이야기가 된다. 용도1 : 조건문의 단축표현condition &amp;&amp; doSomething() 이라면 condition이 참일 때만 뒤 따라오는 doSomething을 호출한다. 12345678910// 1 condition이 true라면 doSomething 함수를 실행if (condition) { doSomething();}// 2 위 코드와 동일하다.condition &amp;&amp; doSomething();// 3 좌결합성이기 때문에 조건을 계속 이어붙일 수 있다.condition1 &amp;&amp; condition2 &amp;&amp; doSomething(); 용도2 : null, undefined에 대한 대응null이나 undefined인 값에 대해 .연산자나 []연산자를 통해 멤버접근을 시도하고자 하면, 속성을 읽을 수 없다는 내용의 TypeError 가 발생한다. &amp;&amp; 연산자를 활용하면 이를 예방할 수 있다. 123const bark = (animal) =&gt; { return animal &amp;&amp; animal.sound;} animal이 null이나 undefined가 아닐 경우 animal.sound에 접근한다.null, undefined 외의 데이터 타입에 대해서는 해당 멤버가 존재하지 않더라도 undefined 만을 반환할 뿐, TypeError가 발생하지 않는다. || - oror 연산자의 경우 앞에 위치한 피연산자의 평가결과가 Truthy 값일 경우굳이 이후의 피연산자를 평가하지 않아도 true가 되기에 || 연산자는 앞쪽의 피연산자의 평가결과를 그대로 반환하고 뒤쪽의 피연산자는 평가하지 않는다. 역으로 생각해보면 or 연산자는 앞에 위치한 피연산자의 평가결과가 Falsy값이라면, 무조건 뒤쪽의 피연산자를 평가하여 그 결과를 반환한다는 이야기가 된다. 용도1 : 조건문의 대용아래의 예제는 and 조건문의 경우와 정확히 반대이다.and 조건문이 어떤 condition이 참일 때 따라오는 피연산자를 호출하였다면,or 조건문은 어떤 condition이 거짓일 때 호출한다. 12345678910// 1 condition이 false라면 doSomething 함수를 실행if (!condition) { doSomething();}// 2 위 코드와 동일하다.condition || doSomething();// 3 좌결합성이기 때문에 조건을 계속 이어붙일 수 있다.condition1 || condition2 || doSomething(); 용도2 : 기본값 설정두 개의 피연산자가 있을 경우, 앞 부분이 falsy값일 때,보통 undefined나 null인 경우 argument가 정상적으로 전달되지 않았다고 가정하고 뒷 부분의 피연산자를 평가해 기본값으로 사용한다. 123456789const bark = (animal) =&gt; { const sound = animal &amp;&amp; animal.sound; return sound || \"호로로로롤\";}// 혹은 &amp;&amp;와 같이 이어붙여서 사용하면.. (체이닝)const bark = (animal) =&gt; { return animal &amp;&amp; animal.sound || \"호로로로롤\";} 두 번째 코드의 경우 조건 연산자의 우선순위가 ||보다 &amp;&amp; 가 높아서 아래와 같이 표현도 가능하지만, 좀 더 명확하게 괄호로 묶어서 표현하거나 위 처럼 별 개의 라인으로 구분지어 놓는 것이 좋을 것 같다. 용도3 : 여러 후보군 중 하나를 골라내야할 때앞 부분에서 Truthy 값이 나오면 뒷 부분을 평가하지 않는다는 특성을 활용해, 있을지 없을지 보장할 수 없는 여러 후보군에 대해 존재하는 하나를 골라낼 때 활용이 가능하다. 각 피연산자들을 같은 용도의 여러 선택지들이라고 가정할 때, 기회비용이 작은 순으로 좌에서 우로 나열해야한다. 123456789/*새로 만들어진 newFunc가 가벼우니까 있으면 먼저 사용해보고,없으면 어쩔 수 없지.. 무겁지만 기존의 legacyFunc라도 사용하자.*/(obj.newFunc || obj.legacyFunc)();(Array.prototype.filter || SomePolyfill.filter)( (v) =&gt; !!v;); 주의사항단락평가의 경우 용도야 만들면 다양하겠지만, 코드의 가독성과 간결성을 위해서가 아니라면 굳이 억지로 사용해서 문법 닌자가 되지 말자.","link":"/2019/10/27/JavaScript/%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/%EB%8B%A8%EB%9D%BD%ED%8F%89%EA%B0%80%20%ED%98%B9%EC%9D%80%20%EC%A7%80%EB%A6%84%EA%B8%B8%ED%8F%89%EA%B0%80/"},{"title":"grep 사용법","text":"정규표현식을 이용한 텍스트 검색 grep [Pattern] [Filename] 일반적인 사용법 [Filename] 에서 [Pattern] 를 찾는다 기본적으로 Basic regular expression을 사용한다 grep -i [Pattern] 대소문자를 무시한다. Ignore Case Basic regular expression 패턴에서 일부 메타문자를 일반 문자로 인식한다. ex : ? , + , { , | , (, ) \\ 를 앞에 붙여줘야 비로서 정규표현식 메타문자로 작동한다 ex : \\?, \\+, \\{ … 굳이 \\를 붙이고 싶지 않다면 아래의 -E 옵션 사용이 가능하다. -E 옵션과 -F 옵션의 한 쌍 grep -ie [Pattern] 두번째 인자를 정규식 표현으로만 취급한다 - 가 들어간 문자열을 검색할 때 용이하다 ex : grep –help | grep -e -e grep –help 문서에서 -e 옵션을 검색한다 grep -Ei [Extended Regular Expression] 확장된 정규표현식에선 메타문자를 굳이 이스케이프하지 않아도 된다. ex : grep –help | grep -Ei ‘\\s(-e|-f)’ grep -Fi ‘(t|f)est’ 정규식을 사용하지 않고 순수 문자열로 검색 egrep과 fgrep egrep 사용시 -E 옵션 생략이 가능하다. ex : grep –help | grep -Ei ‘\\s(-e|-f)’ ex : grep –help | egrep -i ‘\\s-(-e|-f)’ fgrep 사용시 -F 옵션 생략이 가능하다. 경로 내 파일검색 및 하위 경로 탐색 grep [Pattern] ./* 해당 폴더내 파일들을 검색함 grep *-r** [Pattern] ./** 하위 폴더의 파일들까지 모두 탐색함 줄에 대한 정보들 grep *-n** [Pattern] ./** 매칭되는 라인번호를 표시함 grep -c [Pattern] [Filename] 해당 패턴이 매칭되는 줄이 총 몇 줄인지 라인 수를 출력함. 파일 이름 관련 grep *-l*** 파일 이름만 출력함 grep *-h*** 파일 이름을 출력하지 않음 grep *-H*** 파일 이름을 출력함 grep -C[n] [Pattern] [Filename] 매칭된 라인 앞뒤로 n개 줄을 표시함. grep -m[n] [Pattern] [Filename] 파일 당 출력 라인수를 제한함. 저장된 패턴을 활용 grep -f [Filename] [Filename] -f 뒤의 [Filename] 의 내용을 패턴으로 활용해 검색한다.","link":"/2019/10/26/Linux/Shell%20Commands/Grep%20%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0/"},{"title":"리눅스 파일처리 커맨드","text":"파일들을 조회하고, 지우고, 잘라내고, 복사하고, 바로가기를 만든다 ls - List ls -a 숨김파일 포함해 전체 출력. ls -A -a 와 동일하되 .와 ..를 제외하고 출력. ls -l 리스트 형태로 출력. ls -l (기본값) 기본적으로 최종 수정시간을 표시한다 (Modified) ls -lc -l 옵션에서 시간을 최종 변경시간으로 표시 (Changed) ls -lu -l 옵션에서 시간을 최종 접근시간으로 표시 (Access) ls -h 파일크기를 KB, GB, MB 단위로 알아보기 쉽게 출력. (Human) ls - 정렬 관련 옵션 ls -t 시간순으로 정렬 ls -ct 파일을 최종 변경시간 기준으로 정렬 (Changed Time) ls -t (기본값) 파일을 최종 수정시간 기준으로 정렬 (Modified Time) ls -*ut* 파일을 최종 접근 시간 기준으로 정렬 (A**ccess Time) ls -S 파일 크기 순서대로 정렬 ls -r 역순으로 정렬 ls - 시간 표기방법 변경 ls -lh *–time-style=long-iso*** 2019-08-02 와 같은 형태로 출력. ls -lh *–time-style=’+%y/%m/%d %H:%M’*** 19/08/02 23:31 와 같은 형태로 출력. rm - Remove rm -r 디렉토리 삭제. (Recursive, 반복되는, 재귀적인)(Interactive, 반응형) rm \\.c* c 확장자 파일 다 삭제 mv - Move mv -b aa bb aa를 bb로 이동(변경)하는데 bb가 존재할 경우 bb의 백업파일을 생성한다. cp - Copy cp ./aa/\\ bb* ./aa 안의 모든 파일을 bb 폴더로 옮긴다. cp -p aa bb aa의 권한, 소유주 정보를 그대로 bb로 복사 rm mv cp 명령어의 -i -v -f 옵션에 대하여 -i : Interactive, 동작하기 전 사용자에게 재확인 -v : Verbose, 동작한 내용을 출력 -f : Force, 강제로 동작 mkdir - Make Directory mkdir -p ./aa/bb ./aa 경로가 없을 경우 오류가 출력되나, -p 옵션(Parents) 사용시 ./aa 생성 후 ./aa/bb 생성함. mkdir -m 777 ./aa -m 옵션을 사용해 생성할 디렉토리의 권한을 지정. ln - Link ln aa bb ab라는 이름의 aa를 향한 하드 링크를 생성한다. ln -s aa ab ab라는 이름의 aa를 향한 심볼릭 링크를 생성한다. 하드링크와 심볼릭 링크링크에는 하드링크와 심볼릭링크 두 종류가 있다. 하드 링크 Hard Link원본 파일과 동일한 Inode에 링크한다.원본 파일이 삭제되어도 해당 Inode에 연결된 하드링크 파일이 있다면,(해당 파일의 Inode 상 링크수가 0이 아니라면)해당 파일의 Inode는 Free가 되지 않고하드링크로 해당 파일에 지속 접근이 가능하다.하드링크 파일과 원본 파일은 Inumber가 동일하다.동일한 Inode를 참조하므로 하드링크 생성으로 인해 디스크 공간이 줄어들지 않는다 심볼릭 링크 Symbolic Link새로운 Inode를 생성하고,해당 Inode에는 원본 파일의 주소가 기록되어 있다.당연히, 원본파일이 삭제되거나 경로가 달라지면 더 이상 원본 파일의 내용에 접근이 불가하다.","link":"/2019/10/26/Linux/Shell%20Commands/%ED%8C%8C%EC%9D%BC%EC%B2%98%EB%A6%AC/"},{"title":"리눅스 텍스트처리 커맨드","text":"텍스트 처리에 관련된 기능들 cat 파일의 내용을 출력합니다 cat [Filename] [Filename] 의 내용을 출력합니다 cat [Filename1] [Filename2] … 나열된 파일들을 연이어 출력합니다 cat -n [Filename] 줄 번호를 붙여서 출력합니다 cat을 입력도구로 사용하기 옵션 없이 cat 만을 사용할 경우 입력 도구로 사용이 가능합니다 ex : cat &gt; [Filename] 이후 텍스트를 입력하고 엔터를 치면 해당 파일에 기록이 되기 시작합니다. head - 앞 쪽만 보여줘 cat /etc/passwd | head -n 50 위에서 50 라인만 출력. cat /etc/passwd | head -n -50 아래에서 50 라인 빼고 전부 출력. tail - 아래 쪽 보여줘 로그 조회하는 용도로 많이 사용. tail /etc/passwd -n 50 밑에서 50줄만 보여줘. tail /etc/passwd -F 추가되는 내용을 지속 팔로우하여 출력. 파일이 삭제되었다 다시 생성되어도 re-open하여 계속 팔로우함. -f 옵션의 경우 파일 재생성시 팔로우 안 함. wc - Word Count wc /etc/passwd 줄수 / 단어수 / 바이트 카운트 출력. wc /etc/passwd -l 라인수만 출력함. wc \\.c -l* c파일의 모든 라인수 출력. wc /etc/passwd -l | awk ‘{ print $1 }’ 라인수만 출력함. nl - Number Line nl /etc/passwd nl /etc/passwd -ba 공백 라인에도 줄 번호를 출력. nl /etc/passwd -v 10 번호가 10번부터 시작함. sort - 파일을 정렬 cat /etc/passwd | sort cat /etc/passwd | sort -r -r 리버스. 거꾸로 뒤집는다. cat /etc/passwd | sort -t: -k1,1 -k2,2 -t 옵션으로 구분자를 정하고, -k1,1 -k2,2 옵션으로 첫번째 칼럼과 두번째 칼럼을 기준으로 잡고 정렬함. uniq - 중복 제거 cat /etc/passwd | awk -F: ‘{print $1}’ | uniq -i | sort -k 2,2 | nl 유저 이름을 중복없이 알파벳 순으로 정렬. cat /etc/passwd | uniq -i -d -d 옵션은 중복된 값만 출력한다. cat /etc/passwd | uniq -i -u -u 옵션은 중복되지 않은 유일한 값만 출력한다. cut - 잘라내기 cat /etc/passwd cut -d’:’ -f 1,3","link":"/2019/10/26/Linux/Shell%20Commands/%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%B2%98%EB%A6%AC/"},{"title":"시스템 조작","text":"시스템 조작 및 간단한 시스템 정보를 조회하는 방법 shutdown시스템을 종료하거나 재부팅한다 shutdown -h now 즉시 시스템 종료 shutdown -h 15 15분 뒤 시스템 종료 shutdown -h 22:00 22:00 에 셧다운 예약 shutdown -c 예약된 셧다운 취소 shutdown -k +15 15분 뒤 종료 예정이라고 전 사용자에게 경고 shutdown -r 재부팅 w, who, whoami, users접속중인 사용자들에 대한 정보를 조회한다 w 현재 접속한 사용자 목록 출력 who 위와 동일 who -b 시스템 부팅시간 출력 UTC로 표기가 되므로, 한국 시간을 알고싶다면 -9시간을 계산해야 된다. UTC(Universal Time + Coordinated, 협정세계시간) 한국은 UTC+9 (UTC에 9시간을 더함) 를 사용한다. whoami 현재 로그인된 호스트명 출력 users 접속된 사용자 리스트를 나열 idid에 관련된 조회 동작을 실시한다 id -un 현재 호스트명 출력 id 1000 -un uid 1000의 호스트명 출력 id -u 현재 로그인된 계정의 uid 출력 finger특정 유저의 이름, 메일, 로그인시간 등의 정보를 확인한다 finger -s 현재 로그인된 계정의 정보를 출력 finger -s username username으로 지정한 유저의 정보를 출력 md5sum 특정 파일의 md5 체크섬을 확인 md5sum filename md5 체크섬을 출력. df - Disk Free디스크 사용정보를 출력 df *-text4 -hT*** -h 옵션으로 읽기 쉬운 단위로 출력 -T 옵션으로 파일시스템 정보를 출력 -t[type] 옵션으로 해당 파일시스템의 파티션만 필터링 du - Disk Usage디스크 사용량을 표시한다 du *-hs*** -hs -&gt; Human Readable, Short 사람이 읽을 수 있게 요약해서 총량만 출력 dur *-hsS*** -S 하위 파일 제외 순수 현재 폴더만의 디스크 사용량 표시 free - Memory Usage메모리 사용량을 표시한다 free *-hs1*** -s1 1초에 한 번씩 사용현황을 append -t 총 사용량 행을 가장 아래에 출력","link":"/2019/10/26/Linux/Shell%20Commands/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A1%B0%EC%9E%91/"},{"title":"객체를 복사하는 방법","text":"객체를 복사하는 방법들에 대해 알아보도록 하겠습니다.다양한 복사방법들을 알아보고, 얕은 복사와 깊은 복사의 차이점과 한계점 그리고 해결법에 대해 알아보도록 하겠습니다. 리터럴 표기법을 활용한 복사리터럴 표기법은 객체를 생성하는 가장 일반적인 방법입니다.쉼표로 구분된 키-값 쌍의 요소들을 중괄호로 감싸서 선언합니다. 1234567891011121314const Dog = { name: \"앵두\", age: 2, sound: \"멍멍\", bark() { console.log(this.sound); }, events: [ { no: 1, description: \"거품토를 했다\" } ]}; 우선, 이 리터럴 표기법을 활용해 객체를 복사하는 방법을 알아봅시다. 전개 구문을 이용해 객체 복사하기전개 구문을 이용해 다른 객체의 내용을 복사할 수 있습니다.아래의 코드에서 새로 생성된 cpDog는 Dog 객체와 동일한 내용을 가진 클론 객체가 됩니다. 123const cpDog = { ...Dog}; 다른 객체를 기반으로 새로운 객체 생성다른 객체의 내용을 기반으로 새로운 객체를 생성합니다.아래의 SuperDog는 Dog와 동일한 내용을 가졌지만, sound 속성과 name 속성을 새로 선언한 값으로 덮어 씌웠습니다. (오버라이딩) 12345const SuperDog = { ...Dog, name: \"광견\", sound: \"으르렁쾅쾅!!\"} 얕은 복사 문제앞부분에 선언된 Dog 객체를 잘 보시면 events 속성의 값이 배열로 이루어진 것을 보실 수 있습니다.전개 구문을 이용해 객체 복사를 할 경우 이 events 속성은 cpDog의 events 속성으로 참조 복사가 됩니다. 즉, cpDog의 events 속성에 새로운 사건을 추가하면 Dog 객체의 events 속성에도 동일한 수정사항이 발생합니다. 1234567cpDog.events.push({ no: 2, description: \"초콜렛을 먹었다\"});console.log(Dog.events[1]);// 출력 : Object {no: 2, description: \"초콜렛을 먹었다\"} 이러한 것을두고 객체가 얕게 복사된다고 하며, 얕은 복사 문제라고도 합니다. 이는 의도치 않은 외부효과가 발생하여 버그의 원인이 될 수 있습니다. Object.assign Object.assgin([대상객체명], [원본객체명]]) 이름 그대로 대상이 되는 객체로 원본 객체의 내용을 할당합니다.앞서 리터럴 표기법 부분에서 전개 구문을 이용해 객체 복사하기 와 비슷한 기능을 수행합니다. 역시 얕은 복사가 진행이 되는 점에 유의하여 주십시오. 1const cpDog = Object.assign({}, Dog); // Dog 객체의 클론 만들기 아래의 코드는 결과값이 어떻게 될까요? 12345const cpDog2 = { sound:\"야옹\"};Object.assign(cpDog2, Dog); 전개 구문을 통해 복사를 할 때는 복사를 받고자하는 객체(cpDog)에 복사 해주는 객체(Dog)와 동명의 프로퍼티(sound)를 삽입하게되면, 복사를 받고자하는 객체(cpDog)의 값으로 덮어쓰기(오버라이딩)가 되었던 것을 기억하실겁니다. 하지만, Object.assign의 경우엔 대상 객체인 cpDog2의 sound 속성을 원본 객체인 Dog의 sound 속성이 덮어 씌워버립니다. 즉 원본 객체의 값을 우선시하여 복사합니다. 구체적으로 말하자면, Object.assign은 원본 객체의 속성들을 다시 대상 객체로 ‘할당’하기 때문에, 당연히 원본 객체에 남아있던 기존 속성들을 덮어쓰기가 된다는 이야기입니다. JSON을 활용한 깊은 복사JSON은 JavaScript Object Notation의 의미를 가진 두문자어입니다. 그대로 번역하면 자바스크립트 객체 표기법 이 되는데,JSON은 자바스크립트의 객체를 리터럴 표기법과 비슷한 모양새로 ‘문자열’로 변환하고, 변환된 문자열을 다시 객체로 되돌리는 기능을 제공합니다. JSON.stringify([객체명]) - 객체를 JSON 문자열로 변환 JSON.parse([JSON문자열]) - JSON 문자열을 다시 객체로 변환 1234567891011121314151617const Dog = { name: \"앵두\", age: 2, sound: \"멍멍\", bark() { console.log(this.sound); }, events: [ { no: 1, description: \"거품토를 했다\" } ]};const jsonDog = JSON.stringify(Dog); // Dog를 JSON 문자열로 변환const cpDog = JSON.parse(jsonDog); // JSON 문자열을 객체로 변환 내부 동작Dog 객체가 JSON 문자열로 바뀌면 아래와 같은 형태가 됩니다. 1{\"name\":\"앵두\",\"age\":2,\"sound\":\"멍멍\",\"events\":[{\"no\":1,\"description\":\"거품토를 했다\"}]} 보시다시피 events 속성 역시 내부의 값이 문자열로 변환되어 기록된 것을 확인할 수 있습니다.(적합한 비유일지는 모르겠으나 마치 탁본을 뜬 것과도 같이 events 속성의 내용을 기록해뒀습니다.) 이 문자열을 해석해 마치 리터럴 표기법을 새로 작성하듯 객체를 생성하게 되니, 종전의 얕은 복사 문제는 일어나지 않게 됩니다. 이러한 복사를 깊은 복사 라고 부르며, 위 처럼 JSON을 활용한 방법이 가장 대중적인 것으로 알고 있습니다. 단, 이 방법으로는 내부의 메소드나 getter/setter 까지는 복사가 되지 않는다는 단점이 있습니다. 완전한 깊은 복사아래는 필자가 직접 작성해본 객체의 깊은 복사 코드입니다.중첩된 객체는 물론 메서드와 getter/setter 까지 완전한 복사가 가능합니다. 앞서서 배운 속성 설명자를 십분 활용하여 만든 것입니다. 1234567891011121314151617181920212223242526/** * 객체를 깊이 복사한다 * @param {Object} target 복사를 받을 대상이 되는 객체 * @param {Object} source 복사를 해올 원본이 되는 객체 **/function ObjectDeepCopy(target, source) { if (Array.isArray(source)) return [...source]; const props = Object.getOwnPropertyNames(source); const descriptors = props.map(name =&gt; [ name, Object.getOwnPropertyDescriptor(source, name) ]); for (const [name, descriptor] of descriptors) { if (Array.isArray(descriptor.value)) { descriptor.value = [...descriptor.value]; } else if (typeof descriptor.value === \"object\") { descriptor.value = ObjectDeepCopy({}, descriptor.value); } Object.defineProperty(target, name, descriptor); } return target;} 프로토타입만 똑같이 연결해주면, 쌍둥이라고 봐도 무방하겠네요!이 부분은 이후 문서에서 다시 다뤄보면서 코드를 수정해보도록 하겠습니다 ㅎㅎ","link":"/2019/09/08/JavaScript/%EC%8B%9C%EB%A6%AC%EC%A6%88/%EA%B0%9D%EC%B2%B4%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/4.%20%EA%B0%9D%EC%B2%B4%EB%A5%BC%20%EB%B3%B5%EC%82%AC%ED%95%98%EB%8A%94%20%EB%B0%A9%EB%B2%95/"},{"title":"Find 사용법","text":"Find 유티리티에 대한 별도 정리자료","link":"/2019/10/26/Linux/Shell%20Commands/%EC%9E%91%EC%84%B1%EC%A4%91/Find%20%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0/"},{"title":"사용자 관리","text":"사용자 관리에 대한 별도 정리자료 권한에 대하여소유주, 그룹, 그 외 사람들rwx 로 권한을 표기한다/etc/passwd 에 대하여/etc/shadow 에 대하여과거에는 /etc/passwd 파일에 직접 인코딩된 암호를 기록하여 사용했다. 이후 Shadow Suite의 적용으로 /etc/passwd에 직접 암호를 저장하지 않고,/etc/shadow 에 각 유저에 매칭되는 암호화된 암호와 암호에 관련된 다양한 설정들을 기록해 사용하는 형태로 변모하였다. 보통 /etc/passwd 는 644(rw-r-r)의 권한을 갖고,/etc/shadow는 600(rw-권한없음-권한없음)의 권한을 갖는다. /etc/shadow의 구조/etc/shadow 파일내에는 각 유저들의 암호화된 비밀번호 와 비밀번호에 관련된 설정값 들이 기록되어있다. test:$6$O71pCNwB$GnBKDEYulhNdk0QFEpuDX3Ge(중략 ...):18112:0:99999:7::: 각 필드 살펴보기콜론 : 을 구분자로 사용해 각 필드를 구분한다. 첫번째 - test /etc/passwd 에 기록된 유저명과 매칭이 된다. 두번째 - “$6$O71pCNwB$GnBKDEYulhNdk0QFEpuDX3Ge(중략 ...)“ 암호화된 Password 이다. (동어 반복 느낌이 나서 굳이 영단어를 썼다) 이 역시도 달러기호 $ 를 구분자로 사용해 다시 필드가 나뉜다. 첫번째 - 6 두번째 - O71pCNwB 세번째 - GnBKDEYulhNdk0QFEpuDX3Ge(중략 …) 세번째 - 18112 네번째 - 0 다섯번째 - 99999 여섯번째 - 7 해시함수부록-해시함수.md 를 참고할 것. 쓰고나서 투머치한 감이 없잖게 있어서 따로 항목을 새로 만들었습니다. 사족과도 같은 내용으로 필요한 분만 간단하게 참고하는 용도로 열람하시면 될 것 같습니다. 사용자 추가, 삭제, 수정사용자 추가하기사용자 삭제하기사용자 삭제시 오류 사례사용자 수정하기사용자 목록 확인패스워드 변경그룹 추가, 삭제, 수정그룹 목록 확인UID, GID","link":"/2019/10/26/Linux/Shell%20Commands/%EC%9E%91%EC%84%B1%EC%A4%91/%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B4%80%EB%A6%AC/"},{"title":"객체를 봉인하는 방법","text":"Object 내장 객체에는 객체를 다루기 위한 다양한 정적 메서드들이 포함되어 있습니다.그 중에서도 앞서 설명한 속성 설명자와 연관성이 짙은 몇 가지 메서드들에 대해 알아보려고 합니다. 아래에 알아볼 메서드들은 모두 객체를 사용자가 임의로 확장하고 수정할 수 없도록 봉인하는 방법들을 제공하는 것들입니다. Object.preventExtensions객체가 확장될 수 있다는 것은, 객체에 새로운 구성요소를 추가할 수 있음을 의미합니다.Object.preventExtensions([객체명]) 메서드를 사용할 경우 해당 객체는 더이상 확장이 불가능합니다. 이 메서드는 객체의 확장가능성을 비가역적으로 막아버리기 때문에,한 번 확장 불가능하도록 설정한 객체를 다시 확장이 가능하도록 되돌릴 수 없습니다. Object.isExtensibleObject.isExtensible([객체명]) 메서드는 해당 객체가 확장이 가능한 객체인지 확인하여 불리언값을 반환합니다. Object.freezeObject.freeze([객체명]]) 메서드는 이름 그대로 해당 객체를 얼려버립니다. 얼려진 객체는 확장이 불가능합니다. 얼려진 객체의 속성들은 삭제가 불가능합니다. 얼려인 객체의 속성들은 내부속성을 수정하는 것이 불가능합니다. 얼려진 객체의 속성들은 새로운 값의 할당이 불가능합니다. Object.isFrozenObject.isFrozen([객체명]) 메서드는 해당 객체가 얼려진 객체인지 여부를 불리언값으로 반환합니다. 얼려진 객체의 내부Object.freeze 메서드는 다음 코드와 같은 기능을 수행합니다. 1234567891011121314151617181920212223function Freeze(obj) { const props = Object.getOwnPropertyNames(obj); // 확장이 불가능하도록 설정 Object.preventExtensions(obj); // 모든 속성들에 대하여 configurable, writable을 false로 설정. props.map(one =&gt; Object.defineProperty(obj, one, { writable: false, configurable: false }) ); return obj;}const target = { prop1: 1, prop2: { prop2_1: 2 }};const result = Object.isFrozen(Freeze(target));console.log(result); // 출력 : true Object.sealObject.seal([객체명]]) 메서드는 해당 객체를 봉인합니다. 봉인된 객체는 확장이 불가능합니다. 봉인된 객체의 속성들은 삭제가 불가능합니다. 봉인된 객체의 속성들은 내부속성을 수정하는 것이 불가능합니다. 하지만 각 속성에 새로운 값을 할당할 수 있습니다 Object.isSealedObject.isSealed([객체명]) 메서드는 해당 객체가 봉인된 객체인지 여부를 불리언값으로 반환합니다. Object.isSealed([객체명]) 메서드는 객체의 확장가능성과, 각 속성의 configurable 값이 false인지 여부만 검사합니다. 따라서, Object.freeze([객체명])으로 얼려진 객체에 대해서도 true값을 반환합니다. 객체의 봉인된 상태는 얼려진 상태의 부분집합과도 같습니다. 봉인된 객체의 내부Object.seal 메서드는 다음 코드와 같은 기능을 수행합니다. 1234567891011121314151617181920212223function Seal(obj) { const props = Object.getOwnPropertyNames(obj); // 확장이 불가능하도록 설정 Object.preventExtensions(obj); // 모든 속성들에 대하여 configurable만을 false로 설정. props.map(one =&gt; Object.defineProperty(obj, one, { configurable: false }) ); return obj;}const target = { prop1: 1, prop2: { prop2_1: 2 }};const result = Object.isSealed(Seal(target));console.log(result); // 출력 : true 위 메서드들은 모두 비가역적인 결과를 초래합니다확장가능성을 막아둔 객체를 다시 확장가능하도록 되돌리는 방법은 없습니다.또한, configurable이 false로 설정된 객체들에 대해 내부속성의 재정의가 불가능합니다. 따라서, 위 메서드들은 모두 한 번 수행되고나면 절대로 원 상태로 되돌릴 수 없습니다.","link":"/2019/09/08/JavaScript/%EC%8B%9C%EB%A6%AC%EC%A6%88/%EA%B0%9D%EC%B2%B4%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/3.%20%EA%B0%9D%EC%B2%B4%EB%A5%BC%20%EB%B4%89%EC%9D%B8%ED%95%98%EB%8A%94%20%EB%B0%A9%EB%B2%95/"},{"title":"속성 설명자 (PropertyDescriptor)","text":"속성 설명자란 무엇인가객체의 속성들은 그 자체로 객체 내부의 정보와 기능을 표현하지만, 각 속성들은 다시 그 자신들의 값과 성질에 대한 눈에 보이지않는 내부 속성들을 가지고 있습니다. 위에서 말한 속성의 성질이란 이 속성이 읽기전용인지, 나열될 수 있는지 등의 정보를 의미합니다. 자바스크립트에서는 이러한 속성의 세부적인 성질을 직접 설정하거나 조회할 수 있는 방법을 제공하는데, 이 때 이용되는 특수한 객체가 바로 속성 설명자(PropertyDescriptor) 입니다. 생김새속성 설명자는 아래와 같이 약속된 구성대로 정형화된 객체의 모양새를 갖추고 있습니다. 123456{ value: ..., writable: true, enumerable: true, configurable: true} 속성 설명자는 키값으로 value, get, set, writable, enumerable, configureable 을 가질 수 있습니다. 속성 설명자를 확인하는 방법어떤 속성(들)의 설명자를 확인하는 방법은 아래와 같습니다. 특정 한 개의 속성의 설명자를 확인속성 설명자는 Object 내장 객체의 Object.getOwnPropertyDescriptor() 메서드를 이용해 확인이 가능합니다. Object.getOwnPropertyDescriptor(객체, 속성명) 매개변수로 조회하고자하는 객체와 함께 속성의 이름(키값)을 문자열 형태로 받습니다. (문자열이 아닌 값이 오면 내부적으로 형변환을 진행합니다.) 123456789const human1 = { firstName: \"영재\", lastName: \"주\", age: 30};const result = Object.getOwnPropertyDescriptor(human1,\"age\");console.log(result);//출력 : {value: 30, writable: true, enumerable: true, configurable: true} 모든 속성들에 대해 설명자를 확인Object.getOwnPropertyDescriptors(객체) 라는 Object 내장함수를 사용하여 해당 객체의 모든 속성들의 설명자를 일괄 조회할 수도 있습니다. 123456789101112131415161718192021222324252627282930const human1 = { firstName: \"영재\", lastName: \"주\", age: 30};const result = Object.getOwnPropertyDescriptors(human1);console.log(result);/* 출력 :{ firstName: { value: 영재, writable: true, enumerable: true, configurable: true }, lastName: { value: 주, writable: true, enumerable: true, configurable: true }, age: { value: 30, writable: true, enumerable: true, configurable: true }}*/ 속성 설명자를 이용해 속성을 정의하는 방법어떤 속성(들)을 설명자를 통해 정의하는 방법은 아래와 같습니다. 특정 한 개의 속성을 설정속성 설명자를 확인할 때와 마찬가지로 내장객체인 Object의 메서드를 사용합니다. Object.defineProperty(객체, 속성명, 설명자 객체) 매개변수로 조회하고자하는 객체와 함께 속성의 이름(키값)을 문자열 형태로 받습니다. (문자열이 아닌 값이 오면 내부적으로 형변환을 진행합니다.) 그리고 마지막 인자로 해당 속성을 정의하는데 사용할 설명자 객체를 받습니다. 예시1234567891011const arr = [1, 2, 3];Object.defineProperty(arr, \"4\", { value: 5, writable: false, configurable: true, enumerable: true});console.log(arr); // 출력 : [1, 2, 3, undefined, 5]arr[4] = 2; // writable 키를 이용해 읽기전용으로 설정했으므로 오류 발생. 여러가지 속성을 한 번에 설정한 번에 여러가지 속성을 일괄적으로 설정하는 것도 가능합니다. Object.defineProperties(객체, 속성명, { 설명자 객체1, 설명자 객체2, … }) 예시123456789101112131415161718const arr = [];Object.defineProperties(arr, { 0: { value: 1, writable: false, configurable: true, enumerable: true }, 1: { value: 2, writable: true, configurable: true, enumerable: true },});console.log(arr); // 출력 : [1, 2] 설명자의 키 값을 생략했을 때속성 설명자를 기술할 때, 기술하지 않은 키들이 있을 경우의 동작은 다음 두 가지 경우 중 하나입니다. 기존 설명자가 있을 경우즉, 이미 존재하는 속성에 대해 변경을 시도할 때에는 직접 서술한 키값 외에는 기존의 것을 유지합니다. 123456789const arr = [1, 2, 3];console.log(Object.getOwnPropertyDescriptor(arr, \"0\"));// 출력 : Object {value: 1, writable: true, enumerable: true, configurable: true}Object.defineProperty(arr, \"0\", { writable: false });console.log(Object.getOwnPropertyDescriptor(arr, \"0\"));// 출력 : Object {value: 1, writable: false, enumerable: true, configurable: true} 기존 설명자가 없을 경우기존 설명자가 없을 경우, 즉 새로운 속성을 설명자를 통해 할당할 때에는 비어있는 키값은 모두 false를 기본값으로 갖습니다. 123456789const obj = {};console.log(Object.getOwnPropertyDescriptor(obj, \"name\"));// 출력 : undefinedObject.defineProperty(obj, \"name\", { value: \"주영재\" });console.log(Object.getOwnPropertyDescriptor(obj, \"name\"));// 출력 : Object {value: \"주영재\", writable: false, enumerable: false, configurable: false} 이 경우, 123{ value: 1,} 은 123456{ value: 1, writable: false, enumerable: false, configurable: false} 와 같습니다. 속성 설명자의 구성요소이제 속성 설명자의 키값에 대해 각각의 역할과 기능을 알아보도록 합시다. value말 그대로 해당 속성의 ‘값’을 나타냅니다. 12345{ value: function name() { return this.name; }} 이 value 키값에 어떤 값을 지정하고 어떤 속성을 정의할 경우, 해당 속성의 값으로 value에 지정된 값이 할당하게 됩니다. value 예시1234const arr = [1, 2, 3];Object.defineProperty(arr, \"4\", { value: 5 });console.log(arr); // 출력 : [1, 2, 3, undefined, 5] get과 setgetter와 setter 접근자 속성은 get과 set이라는 특수한 설명자 요소를 이용해 정의할 수 있습니다. 1234{ get: [함수], set: [함수]} writable, value와 공존할 수 없음get/set 키값은 writable, value 키값과 함께 선언될 수 없습니다.getter/setter는 할당 연산자를 이용한 문법으로 연결된 메서드를 동작하는 속성으로 writable, value와 공존할 수 없는 것은 사실 당연합니다. 함께 사용하고자 시도할 경우 관련된 오류가 다음과 같이 발생합니다. TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute 같은 속성에 두 개의 get, set을 설정 가능아시다시피 getter과 setter는 동일한 속성명으로 한 쌍을 구성하여 사용할 수 있기에(오버로딩) 하나의 속성에 대해 get, set 키값을 동시에 정의하는 것이 가능합니다. get set 예시123456789101112131415161718const human1 = { firstName:\"영재\", lastName: \"주\",}Object.defineProperty(human1, \"name\", { get:function () { return this.lastName + this.firstName; }, set: function(name) { this.firstName = name.substr(1,2); this.lastName = name[0]; }})console.log(human1.name); // 출력 : \"주영재\"human1.name = \"김개똥\"console.log(human1); // 출력 : Object {firstName: \"개똥\", lastName: \"김\"} writablewritable 키값이 false 일 경우 해당 속성은 읽기전용(read-only)이 됩니다.할당연산자를 통해 새로운 값을 할당하는 것이 불가능해집니다. 123{ writable: false} writable이 false인 읽기전용 속성에 대해 값을 할당하고자하면 다음과 같은 오류가 발생합니다. TypeError: Cannot assign to read only property ‘[프로퍼티명]’ of object ‘[객체명]’ writable 예시1234const arr = [1, 2, 3];Object.defineProperty(arr, \"1\", { writable: false });arr[1] = 3; // 오류 발생 enumerableenumerable 키값이 false 일 경우 해당 속성은 나열 불가능한 상태가 됩니다. 나열이 불가능하다는 의미우리가 어떤 객체의 속성들에 대해 순차적으로 참조를 하고자한다면 크게 두 가지 방법을 생각해볼 수 있습니다. 하나는 for in 루프를 사용하는 것, 둘째는 Object.keys() 함수를 사용하는 것입니다. 이 때 enumerable 키값이 false로 설정된 속성은 위 방법을 통해 참조할 수 없습니다. 예시123456789101112131415161718192021222324const human1 = { name: \"주영재\", age: 30, height: \"174cm\", hobby: \"자바스크립트 공부\"};Object.defineProperties(human1, { height: { enumerable: false }});console.log(Object.keys(human1));// 출력 : [\"name\", \"age\", \"hobby\"]const result = [];for (const one in human1) { result.push(one);}console.log(result);// 출력 : [\"name\", \"age\", \"hobby\"] 여담이지만 enumrable 값이 false 일 경우 크롬 디버거에서도 흐린 값으로 표시가 됩니다. configurableconfigurable 키값을 false로 설정하면 무슨 일이 일어날까요? 더이상 속성의 내부속성을 더이상 재정의할 수 없게됩니다.configurable 값이 false인 경우 Object.defineProperty 메서드를 통해 해당 속성의 내부속성을 재설정하는 것이 불가능합니다. 조금 더 구체적으로 configuralbe이 false인 경우 enumerable, configurable 속성을 다시 변경하는 것이 불가능합니다. 단, value 속성을 변경하는 것은 가능하고 writable 속성이 true일 경우 false로 변경하는 것은 가능합니다. (반대로 writable을 false에서true로 변경하는 것은 불가능합니다.) configurable 속성 그 자신도 더이상 변경이 안 된다는 부분에 주목해주십시오. 즉, 한 번 false로 설정이 되면 해당 속성은 더이상 내부 속성을 변경할 수 없게된다는 이야기입니다. 또한 속성을 삭제할 수 없습니다delete 키워드를 사용하던, 해당 속성에 null 값을 할당하던, 더이상 객체에서 해당 속성을 삭제할 수 없게 됩니다. 예시1234567891011121314151617const human1 = { name: \"주영재\", age: 30, height: \"174cm\", hobby: \"자바스크립트 공부\"};Object.defineProperties(human1, { height: { configurable: false // (*) }});Object.defineProperty(human1, \"height\", { configurable: true});// 오류 : TypeError: Cannot redefine property: height configurable 과 writable 의 차이점configurable과 writable은 별개의 것으로 각각 다른 값을 지정할 수 있습니다.경우의 수가 4가지밖에 되지 않으므로 각각의 경우들에 대해 모두 알아보도록 합시다. writable: false &amp;&amp; configurable: false 할당연산자를 이용한 값의 재할당이 불가능합니다. value 외의 내부 설정의 재정의가 불가능합니다. 이를 어떤 속성이 얼려진 상태라고 합니다. writable: false &amp;&amp; configurable: true 할당연산자를 이용한 값의 재할당이 불가능합니다. defineProperty 메서드를 이용해 값의 재할당이 가능합니다. writable: true &amp;&amp; configurable: false 할당연산자를 이용해 값을 새롭게 할당할 수 있습니다. writable을 false로 바꾸거나 value를 변경하는 것 외의 내부 설정의 재정의가 불가능합니다. 값이 재할당되어도 내부속성은 그대로 유지됩니다. 이를 어떤 속성이 봉인된 상태라고 합니다. writable: true &amp;&amp; configurable: true 내부 설정의 재정의와 할당연산자를 통한 값의 재할당이 가능합니다. 신규 속성을 리터럴 표기법 등 일반적 방법으로 추가시 갖게되는 내부 속성들입니다.","link":"/2019/09/08/JavaScript/%EC%8B%9C%EB%A6%AC%EC%A6%88/%EA%B0%9D%EC%B2%B4%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/2.%20%EC%86%8D%EC%84%B1%20%EC%84%A4%EB%AA%85%EC%9E%90/"},{"title":"자바스크립트의 객체","text":"객체란 무엇인가객체는 키-값의 쌍을 각각의 구성요소로 가지는 자료형입니다. 객체는 자바스크립트에서 가장 중요한 자료형으로써, 현대 자바스크립트 코드의 빌딩 블록과도 같은 역할을 합니다. 숫자나 문자열 같은 원시 자료형을 제외하고는 자바스크립트에서는 대부분의 데이터가 객체 혹은 유사 객체의 형태로 표현됩니다. 객체지향 프로그래밍(Object Oriented Programming)이라는 프로그래밍 방법론에서는 객체를 보다 더 추상적인 개념으로 설명합니다만, 일단 자료형의 측면과 코드내에서 다루는 방법론에 대해 학습을 하고, 이후 해당 방법론을 공부하면서 또 직접 사용해가면서 차근차근 추상적인 정의에 대해 이해를 높이는 것이 좋을 것 같습니다. 생김새객체는 앞서 말씀드렸듯 키-값의 쌍들을 그 요소로 구성하는 자료형으로써, 아래와 같은 생김새를 가졌습니다. 12345// { ... } 로 표현된 객체를 objectSample에 할당합니다.const objectSample = { a: 1, b: 2,} 객체는 기본적으로 위 처럼 자바스크립트 코드내에서 { key: value, … } 의 형태로 표현할 수 있습니다. 이를 객체의 리터럴 표기법 이라고 합니다. 중괄호(Curly brackets) 로 감싸여진 모양새를 가졌고, 각각의 요소를 나타내는 키-값의 쌍들은 반드시 쉼표(,)를 통해 구분이 되어야 합니다. 1const emptyObject = {}; {} 사이에 아무 것도 표기하지 않으면, 빈 객체가 생성됩니다. 빈 객체는 null과 다릅니다. 객체는 위와 같은 리터럴 표기법으로 생성하는 방법 외에도 생성자 함수를 이용하거나, Object 객체의 정적 메소드들을 이용해 동적으로 생성하는 것이 가능합니다. 123456// 생성자 함수를 통한 객체 생성function Dog(name, age) { this.name = name; this.age = age;}const objSample = new Dog(\"앵두\",2); 이 부분은 후속 게시물에서 보다 자세히 다룰 수 있도록 하겠습니다. 키객체에서 키(key)는 어떤 객체에 포함된 데이터의 ‘이름’을 나타냅니다.이 이름을 이용해 객체 속 원하는 데이터에 직접적으로 접근이 가능합니다. 아래에 어떤 객체를 표현한 코드가 있습니다. 1234567const objectSample = { a: 1, b: 2, \"b.c\": 3, var: 4 \"}\": 5}; 위 코드에서 객체에 사용된 ‘키’들은 아래와 같습니다. a, b, “b.c”, var, “}” 객체의 키는 식별자가 아닌 “문자열”로 저장이 됩니다. 그래서 var의 경우와 같이 예약어임에도 불구하고 키값으로 사용이 가능하고, “b.c”나 “}”와 같이 프로그램 코드를 구성하는 토큰으로 사용되는 특수문자 역시도 따옴표로 묶어서 키값으로 사용이 가능한 것입니다. ES6 부터는 Symbol 자료형 의 데이터도 키로 사용할 수 있게 되었습니다. 값 객체의 ‘값’은 특정한 ‘키’에 연결된 데이터를 의미합니다. 123456789101112const objSample = { a: 1, b: \"abc\", c: Symbol.for(\"only One\"), d: null, e: undefined, f: [1, 2, 3], g: { a: 1, b: null }}; 객체는 값으로 무엇이든 다 저장할 수 있습니다. 숫자, 문자열, 불리언, 심볼, null, undefined와 같은 원시 자료형이 하나의 자료형만을 값으로 저장할 수 있다면, 객체는 그 값으로 모든 원시타입과 객체타입(배열과 함수 포함)의 자료형을 저장할 수 있습니다. 키를 이용해 값을 수정하고 조회하는 방법123456789const Dog = {};Dog.name = \"멍멍이\";Dog.age = 2;console.log(Dog.name); // 출력 : \"멍멍이\"const Dog = {};Dog[\"name\"] = \"멍멍이\";Dog[\"age\"] = 2;console.log(Dog[\"name\"]); // 출력 : \"멍멍이\" 위에서 줄바꿈으로 구분된 두 개의 코드뭉치는 모두 같은 결과를 나타냅니다. 키값이 일반적인 변수명처럼 식별자로 활용이 가능한 문자열이라면 점 연산자(.)을 이용해 해당 키값의 자료에 접근할 수 있습니다.키값에 스페이스가 있거나 점이나 괄호 같은 식별자로 활용이 불가한 문자열이 포함되었다면 두번째 코드와 같이 대괄호 연산자([])를 이용해 해당 키값의 자료에 접근 가능합니다. 속성123const Dog = {};Dog.name = \"멍멍이\";Dog.age = 2; Dog 객체에서 Dog.name과 Dog.age 와 같은 각각의 구성요소들을 Dog 객체의 속성 혹은 멤버라고 부릅니다. 메서드12345Dog.bark = function () { console.log(\"월월!\");}Dog.bark(); // \"월월!\"이 출력된다. 속성은 이름이나 나이와 같이 객체의 정보나 상태를 나타내는 변수의 역할을 하기도 하지만, 위와 같이 값으로 함수를 저장해서 해당 객체와 관련된 어떤 동작을 저장하고 필요할 때 호출할 수 있습니다. 이렇게 어떤 함수가 어떤 객체의 멤버로써 존재할 때 이를 특별하게 ‘메서드’ 라고 부릅니다. 12345678Dog = { ... 기타 속성들, bark () { // (*) console.log(\"월월!\"); }}Dog.bark(); // \"월월!\"이 출력된다. 메서드는 위 처럼 function 키워드를 사용하지 않고 단축하여 표기하는 것도 가능합니다.위와 같은 표기법은 객체의 리터럴 표기법 내에서만 유효하고 function 키워드를 사용할 때와 동일한 결과를 나타냅니다. 자신이 속한 객체를 참조하는 방법많은 경우 메서드는 자신이 속한 객체에 저장된 다른 속성을 활용하여 어떤 동작을 수행합니다. 만약 어떤 메서드 내에서 자신이 속한 객체를 참조하고자 할 경우에는 this 라는 키워드를 사용하면 됩니다. 12345678const Dog = { sound: \"멍멍!\", bark: function () { console.log(this.sound); }}Dog.bark(); // 출력 : \"멍멍!\" this 는 함수의 호출 방법에 의해 참조가 달라집니다. 어떤 함수가 호출되면서 새롭게 실행 컨텍스트가 생성될 때, 함수 내부에서 참조할 this의 값을 결정짓게 되는데요. 이러한 과정을 this binding 이라고 합니다. 간단하게 정리한 규칙은 아래와 같습니다. this binding 규칙 . 연산자나 [] 연산자를 이용해 어떤 객체의 멤버로써 메서드를 호출할 시, 해당 메서드 내의 this는 해당 객체로 binding 됩니다. 위 경우가 아닌 함수 호출은 크게 세가지 결과를 나타냅니다. call, apply, bind 로 강제로 binding 한 경우, 당연히 binding된 객체를 this로써 참조합니다. window 혹은 global과 같은 전역 객체를 this로 참조합니다. strict 모드의 경우 undefined 가 됩니다. ECMASript6 부터 추가된 화살표 함수는 호출시 this binding을 하지 않습니다. call 이나 apply 혹은 bind 로도 this를 강제로 binding 할 수 없습니다. 또한, 화살표 함수의 내부에서 this는 렉시컬 환경으로 연결된 스코프 체인에 의해 식별됩니다. addEventListener 의 경우 전달된 이벤트 핸들러가 호출될 시 이벤트 인자(보통 e라고 많이 표기하시는)의 currentTarget 속성을 핸들러에 binding 합니다. 즉, 해당 이벤트가 호출된 요소의 노드 객체를 가리킵니다. 12345678910const Dog = { sound: \"멍멍!\", bark: () =&gt; { console.log(this.sound); }}Dog.bark();// 오류출력 : TypeError: Cannot read property 'sound' of undefined// this 객체에 sound 속성이 존재하지 않아 호출할 수 없다는 내용의 오류 객체의 메서드로 화살표 함수를 사용할 경우 원치않은 결과가 나타날 수 있습니다. 이유는 위에서 설명한 this binding과 관련이 있습니다.(본인의 소속이 어딘지 분간을 못 하거든요..) 메서드를 표기할 때는 메서드이름() { … }와 같은 단축 표기법이나 function 키워드를 이용한 일반 함수 표현법을 사용해주세요. getter와 setter객체는 또한 getter와 setter라는 이름의 특수한 종류의 속성을 가질 수 있습니다.일반적인 객체의 속성을 값 속성(Data properties)이라고 하고 getter와 setter를 접근자 속성(Accessor properties)으로 별도 분류하기도 합니다. 용도human1 객체에서 나이에 대한 속성을 가져올 때 human1.age와 같은 접근법을 사용합니다.마찬가지로 나이를 새롭게 저장할때도 human1.age = 31; 과 같은 표현을 사용하지요. 메서드를 통해 같은 내용의 동작을 수행하고자 하면,human1.getAge()의 반환값을 통해 나이 정보를 조회하고,human1.setAge(32)와 같은 메서드를 통해 새로운 나이 정보를 저장하는 형태를 띄게 될 것입니다. 12345console.log(human1.age);human1.age = 32;console.log(human1.getAge());human1.setAge(32); 보시다시피 전자의 예로 든 일반적인 데이터 속성은 메서드에 비해 데이터를 조회하고 할당하는 방법이 보다 직관적인 모양새를 갖췄습니다. 하지만 메서드로 데이터를 접근하고 설정할 때는 그 나름대로의 장점이 있어서,아래와 같이 데이터에 대해 좀 더 복잡한 형태의 접근과 가공이 가능합니다. 12345678910111213141516const human1 = { firstName: \"영재\", lastName: \"주\", age: 30, getFullName() { return this.lastName + this.firstName; }, setName(name) { this.lastName = name[0]; this.firstName = name.substr(1,2); }}human1.getFullName(); // \"주영재\"를 반환human1.setName(\"김개똥\");// human1 = { firstName: \"김\", lastName: \"개똥\", age: 30, ... } 이러한 데이터 속성과 메서드의 장단점을 섞어서 데이터 속성의 문법으로 메서드를 사용할 수 있도록 만들어진 접근자 속성을 getter와 setter라고 합니다. 12345678910111213141516const human1 = { firstName: \"영재\", lastName: \"주\", age: 30, get name() { return this.lastName + this.firstName; }, set name(name) { this.lastName = name[0]; this.firstName = name.substr(1,2); }}human1.name; // \"주영재\"를 반환human1.name = \"김개똥\";// human1 = { firstName: \"김\", lastName: \"개똥\", age: 30, ... } 가장 아래 두 줄의 human1 객체의 가공된 풀네임에 접근하고 이름을 새롭게 저장하는 코드에 주목해주십시오.마치 데이터 속성에 접근하고 새로운 값을 할당하는 것 같아 보입니다만, 실제로는 해당 속성에 연결된 메서드를 동작시킵니다. 따라서 앞선 두 개의 코드는 동일한 동작을 나타냅니다. 표기방법getter와 setter는 객체의 리터럴 표기법 상에서 [get|set] 이름(…매개변수들) { … 내용 } 의 형태로ㅂ 표현이 가능합니다. 123get function getDescription() { ... 내용} 이러한 표현법은 잘못된 표현법이고 문법 에러를 발생시키며 정상적으로 동작하지 않습니다. getter와 setter를 동적으로 추가하기일반적으로 객체 리터럴 표기법으로 객체의 선언 단계에서 getter와 setter를 미리 설정해두고 사용 합니다만,코드의 실행 단계에서 동적으로 새로운 setter와 getter를 추가하는 것도 가능합니다. getter/setter를 동적으로 추가할 때는 __defineGetter__ 와 __defineSetter__ 메서드를 사용하며 용법은 아래와 같습니다.(언더바가 두 개인 것에 유의하세요) 객체.__defineGetter__(속성명, 연결될 함수) 객체.__defineSetter__(속성명, 연결될 함수) 1234567891011121314151617const human1 = { firstName: \"영재\", lastName: \"주\", age: 30,}human1.__defineGetter__(\"name\", function() { return this.lastName + this.firstName;});human1.__defineSetter__(\"name\", function(name) { this.lastName = name[0]; this.firstName = name.substr(1,2);});human1.name;human1.name = \"김개똥\"; 역시 앞선 코드들과 동일한 동작을 나타냅니다. 변수에 실제로 저장되는 것123const Dog = {};Dog.name = \"멍멍이\";Dog.age = 2; 앞서보았던 코드들 중 하나입니다.무언가 이상한 점이 느껴지시나요? 무심결에 지나쳤을수도 있습니다만, 분명 Dog 변수는 const 키워드를 이용해 재할당이 불가능하도록 설정이 되어있음에도 불구하고,Dog 객체에 내용물을 이것저것 추가하는 모양새를 하고 있습니다. 원시 자료형과 참조 자료형의 차이자바스크립트의 모든 변수는 메모리상 실제 데이터의 주소를 저장합니다.즉, 변수의 이름(식별자)와 실제 데이터를 서로 다른 위치에 보관하는 것이죠. 따라서 원시 자료형과 참조 자료형의 위와같은 특성 차이에 대해, 참조 복사 값 복사의 차이라고 생각하시는 경우들이 많은데.. 사실은 원시 자료형이든 참조 자료형이든 간에 엄밀히 말하면 모든 변수 할당 과정에서 참조 복사가 이루어지는 것입니다. 그렇다면 원시 자료형과 참조 자료형에는 과연 어떤 차이가 있어서 위와 같은 현상이 나타나는 걸까요? const 를 통해 재할당을 막는다는건 변수에 기록된 데이터의 주소를 변경하는 것을 막는다는 것입니다.원시 자료형의 경우 변수에 할당되는 데이터의 주소가 정확히 그 데이터를 가르키고, 모든 데이터는 같은 주소내에서 불변하기에 const는 의도한 바대로 동작하게됩니다. 단, 참조 자료형의 경우 변수에 기록된 데이터의 주소가 다시 해당 값의 속성들의 범위가 기록된 또 다른 데이터의 주소를 참조합니다. 생각보다 다소간 복잡한 구조이고 개념적으로 이해하면 되는 부분일뿐, 직접 우리가 다루어야할 대상은 아니기에 간략하게 알아보고 넘어가겠습니다. 위 내용을 익숙한 자바스크립트 문법으로 추상화를 시켜 표현한다면 다음과 같을겁니다. 1234567891011121314151617181920212223242526272829const 원시자료형_변수 = 주소록.원시자료Aconst 참조자료형_변수 = (주소록.객체B);let 주소록 = { 원시자료A: 데이터.원시자료A, 객체B: 데이터.속성목록B, 배열c: 데이터.속성목록F, ...}let 데이터 = { 원시자료A: \"원시자료입니다.\", 원시자료B: 12345, ... 속성목록B: [ 속성1: 주소록.원시자료E, 속성2: 주소록.원시자료F, 속성3: 주소록.배열C, ... ], 속성목록F: [ 속성1: 주소록: 원시자료Y, 속성2: 주소록: 원시자료Z, ... ]}; 원시 자료형 값들은 할당 연산자(=)를 이용해 변수에 값을 할당하고자하면 해당 데이터의 주소를 직접 저장합니다.그 주소를 찾아가면 어떤 자료를 보관할 수 있는 상자가 나타나고, 숫자나 문자열 같은 데이터를 그대로 상자에 보관되어있는 모습을 상상해보시면 됩니다. 하지만, 객체는 한 단계 더 복잡한 과정을 거치는데 어떤 변수에 참조형 데이터를 할당하고자 할 때에는 자신이 보유한 속성들의 주소록을 목록으로 가진 또 다른 목록 데이터를 저장합니다. 역시 상자에 비유하자면 객체 변수가 가리키는 상자는 개의 이름, 나이, 짖는방법과 같은 데이터들이 그대로 담겨있는 상자가 아니고,그러한 데이터들이 저장된 곳의 ‘위치정보의 목록’을 담아둔 상자를 가리킨다라고 생각하시면 이해하시기가 훨씬 수월할 것입니다. 즉 const로 선언된 변수 상자는 한 번 내용물을 넣어두면 ‘읽기 전용’이 되어버리는 것은 틀림없지만, 그 변수상자에는 객체에 포함된 속성들의 주소록이 연결되어있을 뿐이며, 주소록 자체는 내용을 추가하거나 삭제하는 것이 자유롭습니다. 1const emptyObject = {}; 위 코드가 null이 아닌 이유 역시 위 내용으로 설명이 됩니다.객체에 구성요소가 없을 뿐이지, emptyObject 변수에는 엄연히 어떤 주소가 저장이 되어있기 때문이죠. 재할당시의 차이점12const dog1 = { name:\"앵두\", age:2};const dog2 = dog1; 첫번째 줄에서 선언된 내용으로 인해, dog1이라는 변수 상자에는 { name:”앵두” … } 리터럴로 생성된 속성목록의 주소가 담기게 됩니다.두번째 줄에서 dog1에 저장된 속성목록의 주소가 dog2라는 변수 상자에 저장이 됩니다. 즉, dog1과 dog2는 동일한 목록의 주소를 참조하게 되는 것입니다. 그리하여, 12dog2.name = \"바둑이\"; // dog2의 이름을 변경.console.log(dog1.name); // dog1의 이름을 출력. dog2의 주소로 찾아간 속성의 목록에서 name 이라는 속성의 주소를 “바둑이”라는 데이터의 주소로 변경하고, 두번째 줄에서 dog1을 타고타고 name 이라는 데이터에 접근하게 되면,결국 두 줄 모두 같은 목록을 참조하게 되므로 동일한 값을 출력하게 되는 것입니다. 1234dog2.name = \"바둑이\"; // dog2의 이름을 변경.console.log(dog1.name); // dog1의 이름을 출력.// 출력 : \"바둑이\" 역시 동일한 목록을 가리키고 있기에, 어느 한 쪽의 데이터 변경은 다른 한 쪽에서도 확인됩니다. 반대로 1234567const str1 = \"abcdefg\";const str2 = str1;str1 = \"hijklmnop\";console.log(str2);// 출럭 : \"abcdefg\" 원시자료형은 각 데이터에 직접 연결되는 주소를 보관합니다.즉, 4번째 줄의 str1에 새로운 문자열을 할당할 때에는 해당 문자열이 저장된 새로운 주소를 저장하게 되는 것이므로, 참조 자료형과 같이 동시 변경되는 현상이 일어나지 않습니다. 배열도 객체고 함수도 객체다배열과 함수는 기술적으로 보면 모두 객체입니다.다만, 언어 자체에서 제공하는 기능과 표현방법의 차이가 있을 뿐입니다. 그래서 다음과 같은 것이 가능합니다. 배열의 예123456789101112const arr = [1,2,3,4];arr[\"4\"] = 5;console.log(arr);// 출력 : [1,2,3,4,5]arr.name = \"1부터 4까지의 자연수\";console.log(arr.name);// 출력 : \"1부터 4까지의 자연수\"const obj = {};const obj2 = Object.assign(obj,arr); // obj라는 빈객체에 arr의 내용을 할당console.log(obj2);// 출력 : Object {0: 1, 1: 2, 2: 3, 3: 4, 4: 5…} 함수의 예123456789101112function sayMyName(name) { console.log(name);}sayMyName[\"description\"] = \"이름을 말하는 함수입니다.\";console.log(sayMyName.description);// 출력 : \"이름을 말하는 함수입니다.\"console.log(sayMyName.length);// 출력 : 1 &lt;- 함수의 매개변수 갯수를 의미하는 함수 객체의 내장함수입니다.console.log(sayMyName.name);// 출력 : sayMyName &lt;- 함수의 이름을 의미하는 함수 객체의 내장함수입니다. 그래서 배열과 함수도 참조복사가 됩니다.배열이나 함수가 저장된 변수 역시 속성목록의 주소만 저장되어있을 뿐, 값 자체가 저장되어있지 않기 때문이지요. 12345678const emptyArr = [];function InsertNumberTo(arr) { arr.push(100);}InsertNumberTo(emptyArr);console.log(emptyArr); // 출력 : [100] 위 코드와 같이 어떤 함수에 전달인자(Arguments)로 배열이나 객체, 함수와 같이 참조형 자료를 넘길 경우,함수에서 전달받은 매개변수(Parameters) 역시 동일한 목록의 주소가 할당됨을 유념해야 합니다. 그말인 즉슨, 함수 내부에서 전달받은 배열을 별도의 복사없이 그대로 수정할 경우 외부의 배열이 동시에 수정되는 외부효과(Side effect)가 나타난다는 이야기로, 원치않은 버그의 원인이 될 수 있습니다. 함수는 일급 객체 입니다본문의 맥락에서 살짝 빗나간 여담입니다만,특히 자바스크립트에서 함수는 1급 객체(First-class object)라고 불리웁니다. 프로그래밍 언어에서 1급 객체의 조건은 다음과 같습니다. 변수나 데이터 구조 안에 할당할 수 있어야 한다. 함수 등에 인자로 전달 할 수 있어야 한다. 반환값으로 사용할 수 있어야한다. 자바스크립트에서 함수는 위의 모든 것이 다 가능합니다.이를 이용해 콜백같은 것을 구현하는데 이에 관련해서는 다른 문서에서 보강하여 설명해드리겠습니다. 본문의 맥락상에서 함수와 관련해 참고해야되는 부분은, 인자로 넘겨진 함수 역시 동일한 주소를 참조하고 있다는 사실입니다. 객체는 연관된 기능과 데이터의 집합이다보통 객체는 위의 Dog나 human1과 같이 개개의 사물로 보고 해당 사물에 연관된 변수와 함수들을 속성으로 모아서 사용합니다. 예를들어 객체의 속성은 나이나 이름같은 사물을 설명하는 정보가 되며, 객체의 메서드는 청소하기, 공부하기와 같은 사물의 행동을 의미합니다. 단순히, 짖는다는 행동과 이름과 나이라는 정보가 이곳저곳에 별개의 것으로 존재하는 것 보다는 연관성있는 것들끼리 함께 모아둘 경우 데이터와 함수를 조금 더 효율적이고 직관적으로 활용할 수 있게 됩니다. 이것에 관련된 주제가 바로 객체지향 프로그래밍 입니다. 이후 문서들에서 객체지향과 관련된 내용을 구현 측면에서 다뤄볼 것입니다만,개념적인 측면에서는 인터넷 상에 좋은 자료가 많으니 이후 따로 공부하시는 것을 권해드립니다.","link":"/2019/09/08/JavaScript/%EC%8B%9C%EB%A6%AC%EC%A6%88/%EA%B0%9D%EC%B2%B4%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC/1.%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%20%EA%B0%9D%EC%B2%B4/"},{"title":"디바운싱과 쓰로틀링 (Debouncing and Throttling)","text":"누르면 폭죽이 발사되는 버튼이 있다고 가정해보자.폭죽 한 발을 쏘는데는 100만원의 비용이 든다. 폭죽이 워낙 화려한 폭죽이라 한 번 쏠때마다 값이 비싸기도 하고,한 번 터지면 적어도 3초간은 하늘을 화려하게 불빛으로 수놓는다. 따라서 화려한 3초 동안에는 새로운 폭죽은 사족만이 될 뿐이다. 이벤트로 생각해보자위 예에서 폭죽 발사 버튼을 누르는 것을 하나의 이벤트라고 생각해보자.폭죽을 쏘는 비용은 해당 이벤트에 연결된 핸들러가 실행될 때 걸리는 연산량 혹은 메모리 사용량이 부하되는 정도라고 볼 수 있다. 디바운싱과 쓰로틀링은 필요이상으로 과도하게 반복되는 이벤트로 인한 부하를 완충하는 방법이다. 디바운싱과 쓰로틀링의 개념과 차이비슷한 목적을 가지고 있으나, 작동 방식이 미묘하게 다르다.처음 보면 충분히 헷갈릴 수 있을 정도로 묘한 차이이기 때문에 차근차근 짚어보는 것이 좋을 것 같다. 그럼 다시 서론에서 이야기한 폭죽 발사 버튼의 예를 활용해 개념과 차이를 서술해보겠다.비싼 폭죽을 최대한 아끼면서 화려한 불꽃놀이를 위해 버튼에 무슨 작업을 해야할 것인가..? 디바운싱3초의 시간을 설정해두고,3초 내에는 버튼이 눌려도 폭죽이 발사되지 않도록 조정해두었다. 마구 연타시 폭죽은 발사되지 않고 마지막 버튼을 떼는 순간 3초 뒤 발사된다. 쓰로틀링일단 버튼이 눌리면 3초간 먹통이 된다.그리고 3초 후에는 다시 폭죽이 발사되도록 초기화가 된다. 이제 버튼을 마구 연타를 해도 3초의 발사 간격을 보장해준다. 차이똑같이 3초의 시간을 설정해두고, 버튼을 쉼없이 연타한다고 가정해보자. 디바운싱의 경우 버튼을 누르는 동작이 3초내에 계속 반복될 경우,이벤트는 절대 실행되지 않는다. 특정 시간내에 반복되는 동작은 그 동작이 다 마칠 때까지 일단 무시하는 것이다.‘아무 동작없이 3초가 흘렀다’라는 것을 어떤 목적을 가진 연속된 동작이 마무리된 것으로 간주하는 것이다. 반면, 쓰로틀링의 경우 일단 3초라는 시간이 지나면, 대기가 풀려 다시 이벤트를 처리할 수 있게 된다. 곧, 연속되는 이벤트의 경우 3초 단위로 반드시 실행이 되는 것이다. 용도용도는 역시 쓰기 나름일 것이다.개념을 이해하면 그때그때 맞는 녀석을 골라서 쓰면 될 것이다. 쉽게 생각할 수 있는 기본적인 예들만 살펴보도록 하자. 디바운싱 - ID 중복검사예를 들어 회원가입 폼에서 ID 입력상자에 어떤 id를 입력하면,입력된 값을 서버로 요청을 보내 중복여부를 확인받는 이벤트 핸들러가 있다고 가정해보자. 한 자 한 자 타이핑하는 동안 줄곧 서버로 요청을 보낸다면 10글자 짜리 id를 쓰는데 10번의 요청이 발송될 것이다. 하지만 여기에 한 2초 정도의 디바운싱만 적용을 하여도,한 번의 타이핑이 완료된 이후에 확인 요청을 보내도록 만들 수 있을 것이다. 쓰로틀링 - 스크롤 이벤트보통 웹 서핑을 할 때 스크롤은 그냥저냥 휙휙 넘기는 녀석이다.경우에 따라 다르겠지만, 마우스 휠 한 번을 굴리는데 스크롤 이벤트가 십수회 발생한다. 사실 스크롤 이벤트라는게 그렇게 정교하지 않아도 유저 경험에는 크게 지장이 없다. 스크롤을 통해 측량 작업을 하는 것이 아니기에,일반적인 목적이라면 1초 혹은 0.5초씩 처리를 해도 특별히 불편한 점이 없는 것이다. 구현아래의 두 함수는 특정 이벤트 핸들러를 인자로 받아 디바운싱과 쓰로틀링 기능을 덧 씌워 반환하는 함수이다. 12345678910111213141516171819202122232425262728293031/* * 디바운싱 : Interval 내 반복되는 이벤트를 무시함. */const debounce = (f, interval = 30) =&gt; { let now = null; return (...param) =&gt; { if (now) clearTimeout(now); now = setTimeout(() =&gt; { f(...param); }, interval); }}/* * 쓰로틀링 : 연이은 이벤트의 Interval 단위 실행을 보장. */const throttling = (f, interval = 300) =&gt; { let isPending = false; return (...param) =&gt; { if (!isPending) { isPending = !!setTimeout( () =&gt; { f(...param); isPending = false; }, interval); } }} 사용input 이벤트12345678910const log = console.log;const inputBox = document.getElementsByName(\"textInput\");const inputHandler = event =&gt; { const {value} = event.target; if (value) log(`id 중복여부 확인요청 : ${value}`);}inputBox[0].addEventListener('input', debounce(inputHandler, 500)); 데모 스크롤 이벤트123456789101112const log = console.log;const scrollHandler = event =&gt; { log(\"debounce\");};const scrollHandler2 = event =&gt; { log(\"throttling\");};window.addEventListener('scroll', debounce(scrollHandler, 300));window.addEventListener('scroll', throttling(scrollHandler2, 300)); 데모","link":"/2019/11/09/JavaScript/%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8B%B1%EA%B3%BC%20%EC%93%B0%EB%A1%9C%ED%8B%80%EB%A7%81/"},{"title":"191103의 메모","text":"자바스크립트의 동시성동기 모델의 단점 다른 언어의 멀티 쓰레드를 이용하는 동기 모델의 경우 각 쓰레드별로 메모리를 점유하게 되고 context switching이 발생하게 되면서 메모리와 cpu에 대한 오버헤드가 발생한다. 콜백 Just pass a function that will be called when the task is complete. 1234// file.txt의 읽기가 끝났을 때 읽어온 content를 인자로 미리 예약된 callback을 호출한다.readFile('file.txt', (content) =&gt; { console.log(content);}) 단점 어떤 일을 순차적으로 동작시키거나, 병렬로 동작시키는게 어렵다. for/while try/catch 구조를 포기하게 만든다. 에러 핸들링이 어렵다. 코드 가독성이 떨어진다. 프로미스무엇을 해결했나 순차적, 병렬적 작업들의 쉬운 연결. 에러 핸들링 12345// Promise stylereadFile('confing.json').then(...).then(...) // 순차적 실행.catch(...); // 에러 핸들링 123456789101112fetchJSON('/user-profile') .then(user =&gt; { return fetchJSON(`/users/${user.id}/friends`); }) .then(friendsIDs =&gt; { let promises = friendIDs.map(id =&gt; { return fetchJSON(`/users/${id}`); }); return Promise.all(promises); }) .then(friends =&gt; console.log(friends)); 이벤트루프 이벤트루프는 자바스크립트 런타임이 아닌 호스팅 환경에 종속된다. 이벤트루프를 통해 각 호스팅 환경의 방법으로 이벤트를 스케쥴링하게된다. JS엔진이 호스팅환경에게 “이봐 나는 이제 코드 수행을 중지시킬 거야. 하지만 자네는 네트워크 요청이 모두 끝나면 가져온 데이터를 이용해 이 함수를 호출(call back)해주게.”출처 : 자바스크립트는 어떻게 작동하는가: 이벤트 루프와 비동기 프로그래밍의 부상, async/await을 이용한 코딩 팁 다섯 가지 이벤트루프의 임무콜스택과 콜백 큐를 모니터링한다.콜스택이 비었을 때, 콜백 큐의 첫번째 이벤트 핸들러를 실행시킨다.","link":"/2019/11/03/JavaScript/%EB%A9%94%EB%AA%A8/191103%20%EB%A9%94%EB%AA%A8/"},{"title":"지연로딩 데모","text":"영상 코드스크린샷블로그에 적용된 코드 하이라이트가 엉망이라 캡쳐본을 첨부합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; /* * 디바운싱 : Interval 내 반복되는 이벤트를 무시함. */ const debounce = (f, interval = 30) =&gt; { let now = null; return (...param) =&gt; { if (now) clearTimeout(now); now = setTimeout(() =&gt; { f(...param); }, interval); } } /* * 쓰로틀링 : 연이은 이벤트의 Interval 단위 실행을 보장. */ const throttling = (f, interval = 300) =&gt; { let isPending = false; return (...param) =&gt; { if (!isPending) { isPending = !!setTimeout( () =&gt; { f(...param); isPending = false; }, interval); } } }&lt;/script&gt;&lt;script&gt; (() =&gt; { const boxes = document.getElementsByClassName('box'); const fix = (f, ...args) =&gt; () =&gt; f(...args); const lazyLoading = (nodeList, f) =&gt; { const targetList = Array.from(nodeList); const viewportHeight = window.innerHeight; const result = targetList .map(element =&gt; { return { element, height: window.getComputedStyle(element)['height'], posY: element.getBoundingClientRect().y }; }) .filter(({ height, posY }) =&gt; posY &lt; viewportHeight &amp;&amp; -1 * parseInt(height) &lt; posY) .forEach(({ element }) =&gt; f(element)); }; const handler = fix(lazyLoading, boxes, v =&gt; v.style.opacity = 100); window.addEventListener('scroll', throttling(handler, 500)); })();&lt;/script&gt;&lt;/html&gt;","link":"/2019/11/09/JavaScript/%EB%8D%B0%EB%AA%A8/%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9%20%EB%8D%B0%EB%AA%A8/"}],"tags":[{"name":"해시함수","slug":"해시함수","link":"/tags/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98/"},{"name":"단락평가","slug":"단락평가","link":"/tags/%EB%8B%A8%EB%9D%BD%ED%8F%89%EA%B0%80/"},{"name":"지름길평가","slug":"지름길평가","link":"/tags/%EC%A7%80%EB%A6%84%EA%B8%B8%ED%8F%89%EA%B0%80/"},{"name":"short-circuit evaluation","slug":"short-circuit-evaluation","link":"/tags/short-circuit-evaluation/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell Commands","slug":"Shell-Commands","link":"/tags/Shell-Commands/"},{"name":"객체에 대하여","slug":"객체에-대하여","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/"},{"name":"시리즈","slug":"시리즈","link":"/tags/%EC%8B%9C%EB%A6%AC%EC%A6%88/"},{"name":"디바운싱","slug":"디바운싱","link":"/tags/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8B%B1/"},{"name":"쓰로틀링","slug":"쓰로틀링","link":"/tags/%EC%93%B0%EB%A1%9C%ED%8B%80%EB%A7%81/"},{"name":"메모","slug":"메모","link":"/tags/%EB%A9%94%EB%AA%A8/"},{"name":"이벤트","slug":"이벤트","link":"/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"스크롤이벤트","slug":"스크롤이벤트","link":"/tags/%EC%8A%A4%ED%81%AC%EB%A1%A4%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"지연로딩","slug":"지연로딩","link":"/tags/%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9/"}],"categories":[{"name":"ETC","slug":"ETC","link":"/categories/ETC/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"개념정리","slug":"JavaScript/개념정리","link":"/categories/JavaScript/%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/"},{"name":"Shell Commands","slug":"Linux/Shell-Commands","link":"/categories/Linux/Shell-Commands/"},{"name":"시리즈","slug":"JavaScript/시리즈","link":"/categories/JavaScript/%EC%8B%9C%EB%A6%AC%EC%A6%88/"},{"name":"작성중","slug":"Linux/Shell-Commands/작성중","link":"/categories/Linux/Shell-Commands/%EC%9E%91%EC%84%B1%EC%A4%91/"},{"name":"객체에 대하여","slug":"JavaScript/시리즈/객체에-대하여","link":"/categories/JavaScript/%EC%8B%9C%EB%A6%AC%EC%A6%88/%EA%B0%9D%EC%B2%B4%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/"},{"name":"메모","slug":"JavaScript/메모","link":"/categories/JavaScript/%EB%A9%94%EB%AA%A8/"},{"name":"데모","slug":"JavaScript/데모","link":"/categories/JavaScript/%EB%8D%B0%EB%AA%A8/"}]}