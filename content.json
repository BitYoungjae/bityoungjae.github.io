{"pages":[],"posts":[{"title":"단락평가 혹은 지름길평가","text":"단락평가, 지름길 평가 (Short-circuit evaluation)자바스크립트의 논리연산자를 기본 용도인 참/거짓의 판단을 위해 사용하는 것이 아닌,조건문을 대체해 사용하는 일종의 문법 설탕이라고 볼 수 있다. 기본원리단락평가는 결국 조건연산자가 가진 아래의 두가지 특성을 응용한 것이다. 조건연산자의 좌결합성and연산자(&amp;&amp;)와 or연산자(||) 모두 좌결합성을 가진다.즉, 피연산자의 평가순서가 왼쪽부터 오른쪽 순으로 진행이 된다. 조건연산자의 평가결과조건연산자는 Boolean 값을 반환하지 않는다.최종적으로 평가된 피연산자의 평가결과를 반환한다. &amp;&amp; - andand 연산자의 경우 앞에 위치한 피연산자의 평가결과가 Falsy값일 경우굳이 이후의 피연산자를 평가하지 않아도 false가 되기에&amp;&amp; 연산자는 false로 평가된 피연산자 이후의 피연산자를 평가하지 않는다. 역으로 생각해보면 and 연산자는 앞에 위치한 피연산자의 평가결과가 Truthy값 이어야만,뒤쪽의 피연산자를 평가하여 그 결과를 반환한다는 이야기가 된다. 용도1 : 단순 if문의 대체12345678910// 1 condition이 true라면 doSomething 함수를 실행if (condition) { doSomething();}// 2 위 코드와 동일하다.condition &amp;&amp; doSomething();// 3 좌결합성이기 때문에 조건을 계속 이어붙일 수 있다.condition1 &amp;&amp; condition2 &amp;&amp; doSomething(); 용도2 : null, undefined에 대한 대응null이나 undefined인 값에 대해 .연산자나 []연산자를 통해 멤버접근을 시도하고자 하면,속성을 읽을 수 없다는 내용의 TypeError 가 발생한다. &amp;&amp; 연산자를 활용하면 이를 예방할 수 있다. 12345678const bark = (animal) =&gt; { /* animal이 null이나 undefined가 아닐 경우 animal.sound에 접근한다. null, undefined 외의 데이터 타입에 대해서는 해당 멤버가 존재하지 않더라도 undefined 만을 반환할 뿐, TypeError가 발생하지 않는다. */ return animal &amp;&amp; animal.sound;} || - oror 연산자의 경우 앞에 위치한 피연산자의 평가결과가 Truthy 값일 경우굳이 이후의 피연산자를 평가하지 않아도 true가 되기에|| 연산자는 앞쪽의 피연산자의 평가결과를 그대로 반환하고 뒤쪽의 피연산자는 평가하지 않는다. 역으로 생각해보면 or 연산자는 앞에 위치한 피연산자의 평가결과가 Falsy값이라면,무조건 뒤쪽의 피연산자를 평가하여 그 결과를 반환한다는 이야기가 된다. 용도1 : 기본값 설정두 개의 피연산자가 있을 경우, 앞 부분이 falsy값일 때,보통 undefined나 null인 경우 argument가 정상적으로 전달되지 않았다고 가정하고뒷 부분의 피연산자를 평가해 기본값으로 사용한다. 12345678910111213const bark = (animal) =&gt; { const sound = animal &amp;&amp; animal.sound; return sound || \"호로로로롤\";}// 혹은 &amp;&amp;와 같이 이어붙여서 사용하면.. (체이닝)const bark = (animal) =&gt; { /* 조건 연산자의 우선순위가 ||보다 &amp;&amp; 가 높아서 아래와 같이 표현도 가능하지만, 좀 더 명확하게 괄호로 묶어서 표현하거나 위 처럼 별 개의 라인으로 구분지어 놓는 것이 좋을 것 같다. */ return animal &amp;&amp; animal.sound || \"호로로로롤\";} 용도2 : 여러 후보군 중 하나를 골라내야할 때앞 부분에서 Truthy 값이 나오면 뒷 부분을 평가하지 않는다는 특성을 활용해,있을지 없을지 보장할 수 없는 여러 후보군에 대해 존재하는 하나를 골라낼 때 활용이 가능하다. 각 피연산자들을 같은 용도의 여러 선택지들이라고 가정할 때,기회비용이 작은 순으로 좌에서 우로 나열해야한다. 12345/*lightFunc가 가벼우니까 있으면 먼저 사용해보고,없으면 어쩔 수 없지.. 무겁지만 heavyFunc라도 사용하자.*/(lightFunc || heavyFunc)(); 주의사항단락평가의 경우 용도야 만들면 다양하겠지만,코드의 가독성과 간결성을 위해서가 아니라면 굳이 억지로 사용해서 문법 닌자가 되지 말자.","link":"/2019/10/27/JavsScript/%EB%8B%A8%EB%9D%BD%ED%8F%89%EA%B0%80_%ED%98%B9%EC%9D%80_%EC%A7%80%EB%A6%84%EA%B8%B8%ED%8F%89%EA%B0%80/"},{"title":"해시함수에 대하여","text":"해시함수란해시함수는 임의의 길이의 데이터를 입력받아 일정한 길이의 비트열로 반환 시켜주는 함수이다. 입력값의 길이가 달라도 출력값은 언제나 고정된 길이로 반환한다. 동일한 값이 입력되면 언제나 동일한 출력값을 보장한다. 암호화 해시 함수란암호화 해시 함수 는 이 해시함수의 부분집합으로 역상저항성과 제2역상저항성 그리고 충돌저항성을 가지고 있어 암호화에 활용될 수 있는 경우를 의미한다. 암호화 해시 함수의 특성과 효과들 역상저항성은 입력값 A에 의해 B가 출력되었다면, 출력된 B값만 주어졌을 때 입력값인 A값을 찾는 것이 계산적으로 불가능함을 의미한다. 제2역상저항성 은 입력값 A와 출력값 B가 모두 주어졌을 때, 똑같은 B를 반환하는 A2 를 찾아내거나 만들어내는 것이 계산적으로 불가능함을 의미한다. 단방향 암호화라고도 하는데 양방향 암호화가 A를 B로 암호화하고 다시 B를 A로 복호화하여 원본 내용을 확인할 수 있다면, 단방향 암호화는 A로 만들어진 B를 가지고 다시 A로 역산할 수 없다. 충돌저항성은 똑같은 B라는 출력값이 나오는 X가 단일하지 않고 중복이 되는 또 다른 Xn을 발견하는 것이 계산적으로 어려운 성질을 의미한다. 충돌저항성은 제2역상저항성의 외부효과(부수효과, Side effect) 이자 부분집합 이다. 압축효과 암호화 해시 함수가 반환하는 일정한 길이의 작은 해시값만으로 크기가 거대한 데이터의 무결성을 보장할 수 있는 외부효과를 의미한다. 예를 들어 SHA-256의 경우 100GB의 파일도 단 256bit의 해시값으로 그 내용의 무결성을 보장할 수 있다. 눈사태 효과눈사태 효과 란 입력값의 아주 작은 변화로도 결과값이 전혀 다르게 도출되는 효과를 의미한다.입력값에 점 하나만 추가되어도 전혀 다른 출력값이 출력된다. 또한 변경되는 부분에 있어 어떠한 규칙성도 찾을 수 없다. 예시아래는 SHA1 함수를 이용해 비슷한 문자열을 암호화한 결과값들이다. “주영재” -&gt; DDB0ED48A84B6C328E50B3BFB3D15364C669C3A6 “주영째” -&gt; 1C2FC56A4172A9B6D5C3C20309A46C01896D3194 “주형재” -&gt; 1DA926EEF1EF8533F57A45124871F8550A278EA9 용도 파일의 Checksum(검사합)을 구한다. SuperVaccine.exe 이라는 가상의 컴퓨터 바이러스 백신 프로그램을 다운로드 받았다고 가정해보자. 만약에 어떤 블랙 해커가 해당 백신 사이트를 해킹해서 설치파일을 비슷한 모양새로 동작하지만 오히려 치명적인 바이러스가 포함된 파일로 변조를 했다면 .. ? 혹은 다운로드 프로그램의 문제나 보관 방식의 문제로 인해 어떤 파일의 내용에 부분적인 결손이 의심된다면 … ? 우선 전자의 경우 블랙 해커는 제2역상저항성 으로 인해 똑같은 Checksum을 가지는 바이러스 파일을 만들 수 없다. 눈사태효과로 인해 아주 미세한 결손이나 위변조가 발생되어도 Checksum 값이 완전히 달라지게 된다. 이 때 내가 받은 설치파일이 올바른 파일이 맞는지 또 제대로 손실없이 받아진 파일이 맞는지 확인하기 위해 해당 설치파일의 데이터를 입력값으로 하여 생성된 해시값을 공식 홈페이지나 다른 공인된 인터넷 페이지에 공개된 해시값과 비교하여 검증할 수 있다. 이상이 없는 파일이라면 내가 받은 파일을 같은 함수로 검증했을 때, 공개된 해시값과 동일한 해시값이 출력될 것이기 때문이다. 마치 해시값을 어떤 데이터의 지문Fingerprint 처럼 활용하는 경우이다. 암호를 저장한다 회원가입 기능을 제공하는 인터넷 서비스를 만든다 가정했을 때 가입된 회원들의 암호를 날 것 그대로 저장하면 안된다. 사용자 암호의 원문이 아닌 해시 암호화한 값을 DB에 저장해놓고, 이후 회원이 로그인을 시도할 때 입력한 암호를 동일한 해시함수로 암호화하여 DB의 해시값과 비교한다. 이 경우 원본 암호를 서버에 기록하지 않고도 유저들은 불편함 없이 평소에 사용하던 암호를 로그인에 활용할 수 있게 된다. 또한, 우리의 가상 서비스가 해킹이 되어 회원들의 DB가 유출이 되더라도 해커는 역상저항성으로 인해 회원들의 진짜 암호를 알아낼 수 없다. 해시테이블에서의 활용. 어떤 데이터의 목록에서 특정 데이터를 조회한다고 생각해보자. 일반적인 방법으로는 데이터를 첫번째 순서부터 하나하나 대조해보거나 특정한 규칙에 따라 순차적으로 각 요소들을 대조하여 특정한 값을 찾아내는 방법이 있다. 해시함수의 충돌저항성을 활용해 데이터를 저장할 때 해당 데이터의 해시값을 별도로 원하는 데이터를 찾아낼 수 있는 ‘키값’ 으로 활용한다면? 각 데이터의 전체값을 비교하지 않고도 일정 길이의 해시값을 이용해 원하는 데이터를 찾아낼 수 있다. 별도의 탐색절차 없이 그 즉시 원하는 데이터를 추출할 수 있으므로 궁극의 탐색 알고리즘이다. 블록체인에서 해시함수의 쓰임새아래의 내용은 필자가 관련 분야의 전문가가 아님을 감안하고 읽어주면 감사하겠다. 블록체인을 아주 높은 수준에서 추상화해서 다음 블록이 그 이전 블록에 체인을 걸고 또 다음 블록이 그 이전 블록으로 체인을 걸고.. 이런 식으로 기차들 처럼 모든 블록들이 선형으로 줄줄이 이어져 있는 모양새라고 생각해보자. 앞선 블록들은 어떤 목적을 위해 포함하고 있는 내용들이 절대 변경되서는 안된다라고 규칙을 정했을 때..(코인의 과거 거래 이력은 상식적으로 당연히 변동이 있어서는 안된다) 이를 실현하기 위해 각 블록들은 자기 자신의 ‘내용’을 해싱해서 해시값을 갖고(블록헤더라고 칭해보자), 자기자신의 해시값을 갖고 있음은 물론 그 이전 블록의 해시값을 참조하게 된다.(이전 블록의 해시값을 다음 블록이 참조한다라는 것을 앞서 이야기한 체인을 거는 비유의 구체적인 실체이다) 혹시라도 어떤 나쁜 사람이 자신의 이익을 위해 가거 블록의 내용을 변경하게 된다면 그 블록의 해시값이 변경되고(눈사태효과, 쇄도효과에 의해)..그 이후 블록은 이전 블록을 해시값으로 참조하고 있기 때문에 연결이 단선되고, 만약에 그 나쁜 사람이 변경된 내용을 거래에 참여하는 모든 사람들에게 인정받고자 한다면 그 이후 모든 블록들의 해시값을 전부 다시 만들어 내야 될 것이다. 위 설명에서 블록체인에서 해시함수는 각 블록을 연결시키는 체인의 용도로써, 또 과거 이력의 변경을 감지하는 역할로써 사용한다라고 정리해볼 수 있을 것이다. 블록체인에서 해시함수의 또 다른 용도에 대해 설명해보겠다. 비트코인과 관련하여 ‘채굴’이라는 용어를 많이 들어봤을 것인데, ‘채굴’을 조금 더 전문적인 용어로 작업증명(Proof of work)이라고 하고, 그 진짜 의미는 ‘해시함수를 활용한 어떤 퍼즐을 풀어내는 일’이다. 해시함수를 이용해 의도적으로 계산적 소모량을 유발하는 퍼즐을 만들어 이 퍼즐을 풀어냈을 때 작업증명을 해냈다 혹은 채굴에 성공했다라고 한다. 그 과정을 대략적으로 설명하자면,우선 해당 블록의 거래내역을 참조한 해시값(정확한 용어로 Merkle root 해시값), 이전 블록의 블록해시, 블록 생성시각 등등 고정된 데이터들의 집합이 재료로 주어지고, 이 변경될 수 없는 데이터에 nonce 라는 이름의 Salt(해시값을 바꾸기 위해 첨가하는 임의의 숫자) 를 계속 바꿔 더해가며 특정한 조건의 SHA256 해시값을 찾는 과정이라고 보면된다. 이 조건이라는 것은 nonce를 계속 증가시켜가며 만들어낸 해시값이 00000000A84B6C328E50B3BFB3D15364C669C3A6 와 같이 앞에 0이 몇 개 이상 있어야 된다 같은 것이다. 확률적으로 (1/16)n이 될텐데,암호화 해시함수를 통해 특정 해시값을 만들어내기 위해선 어떠한 지적 추론도 불가능하고 오로지 컴퓨팅 파워를 이용한 수많은 시행착오를 반복할 수 밖에 없다는 특징을 응용한 것이다. 앞서 체인을 만드는 용도로써 해시함수를 설명할 때, 과거 내용을 변조하려는 공격자의 예를 들었는데.. 이 공격자가 왜 공격을 실패할 수 밖에 없는지..해시퍼즐을 통해 유발되는 계산적 소모량이 그 정답이 된다.변조하려는 블록부터 시작하여 이후 모든 블록의 해시값을 계산해야되고 그 이후 새롭게 생성되는 블록들의 해시값도 전부 다 다시 계산해야 한다면..어떤 누가 쉽게 공격을 하려는 의지를 갖을 것이며, 그 공격이 성공할 수 있을까? 취약한 부분과 충돌쌍y = 2x 라는 함수를 가정했을 때 y가 A인 x를 찾아내는 과정을 역산이라고 한다. y가 12라면, 12 = 2x 12 / 2 = x 6 = x 해시함수는 그 구현내용이 공개되어 있음에도 이러한 과정으로 원본값을 알아내는 역산이 계산상 불가능하다. 하지만 역산 외의 방법으로도 B를 반환하는 An에 대해 탐색할 수 있는 다양한 방법들이 존재하는데 예를 들자면, 해당 해시함수에 의해 도출될 수 있는 방대한 경우의 수를 기록해 사전과 같은 형태로 만들어둔 후 해당 사전에서 A값을 찾아내어 대조해보는 방식(Rainbow attack) 이나, 반환값 B가 나오는 A 혹은 A2를 찾기 위해 임의의 경우의 수를 f(x)의 x에 무차별적으로 대입하여 찾아내는 방법(무차별 대입법, Brute-force attack)이 있을 수 있다. 단순 무식한 방법처럼 보일 수 있으나 컴퓨터는 이러한 단순 작업을 불평없이 수억번 수백억번 반복 수행하는데 특화된 기계이다. 또한, 컴퓨팅 파워가 나날이 발전하고 해시함수 연산을 위한 주문형 반도체가 등장하면서 현재의 암호화 해시 함수는 미래에 보안상 완결성을 상실할 가능성을 충분하게 가지고 있다. 일례로 1977년에 개발된 어떤 암호화 함수(RSA-129)의 개발자(Ronald Rivest)는 자신의 함수로 암호화된 메시지가 해독되는데 4경년이 걸릴 것으로 자신있게 예상했으나, 불과 17년 만인 1994년에 해독이 되어버린 사례가 있다. 더 가까운 과거의 사례로는 MD5 라는 암호화 해시 함수의 예를 들 수 있는데, 현재 MD5 해시값을 복호화하는 인터넷 사이트를 구글링만으로 쉽게 찾아볼 수 있는가 하면, MD5 Decryption - (MD5에 대한 Rainbow attack 의 예시) 심지어 서로 다른 문자열을 출력하는 두 개의 프로그램이 각각 똑같은 MD5 해시값을 갖는 경우도 발견되어 있다. MD5 Collision Demo 2011년까지 미국 표준으로 자리 잡았던 SHA1의 경우에도 충돌쌍(똑같은 해시값을 반환하는 서로 다른 데이터의 쌍) 이 아래와 같이 발견된 예시가 있다.해당 페이지에서는 동일한 SHA1 체크섬을 가진 두 개의 다른 PDF를 예시로 들고 있다. SHA1 충돌쌍 예시 생각해보면 입력값의 길이가 출력값의 길이보다 길어질 수 있다면 출력값의 충돌은 필연적으로 발생할 수 밖에 없기도 하다. 즉, 충돌쌍을 발견함에 있어서 충돌되는(중복되는) 경우가 확률적으로 아주 희소할지 몰라도, 무조건 하나 이상은 100%의 확률로 존재할 수 있다. (비둘기집 원리) 생일 역설 Birthday Paradox역설이란 보통 일반적인 생각에 반대되는 이론이나 말을 뜻한다. 일반적인 상식으로 당연히 A 가 맞다고 생각해왔는데 과학적으로 검증해보니 사실은 전혀 엉뚱한 B 가 진실인 경우들이 있다. 이 생일 역설 역시 그런한 경우인데, 이 역설은 처음 아래의 질문에서 출발한다. “n명의 사람이 임의로 모였을 때 우연히 생일이 중복되는 사람이 두 명 이상 있을 확률은 얼마나 될까?“ 일단 1년은 365일 이므로 366명이 모이면 비둘기집 원리에 따라 100% 최소 한 쌍은 생일이 중복될 것이 분명하다. 이렇게 생각해보자당신은 방송국 PD이다.세간에 유명한 “생일이 같은 사람은 비슷한 성격을 갖는다” 라는 속설에 대한 실험카메라 프로그램을 만들고자 한다. 그래서 생일이 같은 사람을 찾아야 하는데,문득 그런 사람들을 찾자고 (비둘기집 원리에 따라)366명이나 인터뷰를 해야되나라는 생각이 드니 눈 앞이 아득해지기 시작한다. 파일럿 프로그램이라 주어진 시간적, 경제적 자원이 많지 않기 때문이다. 그렇다고 좋은 기획을 날리기는 싫어서 울며 겨자먹기식으로 밖으로 나가 사람들을 인터뷰하는데 겨우 51명째에 벌써 생일이 같은 두 사람을 찾아내 버렸다. 당신은 속으로 생각한다. “이거 정말 운이 좋구만! 우리 프로그램이 잘 되려는 징조인가보다!“ 과연 그럴까과연 당신은 정말 기가 막히게 운이 좋았던 것일까? 사실은 아니다. 왜냐하면 사실 임의로 모인 50명의 사람들 중에서 생일이 중복되는 사람을 한 쌍 이상 찾아낼 확률이 무려 97% 이상 되었기 때문이다. 이번엔 100% 가까운 확률까지는 필요 없으니 그냥 두 번 조사했을 때 한 번만 나와도 되게끔 50% 정도로만 목표를 낮춰보겠다고 하자. 이 때 필요한 인원수를 계산하면 놀랍게도 그 수는 23명으로 파격적으로 줄어들게 된다. 이렇듯 확률의 목표값을 활용 가능한 범위내로 아주 약간 낮춤으로써 중복된 값을 찾아내는 비용을 파격적으로 낮출 수 있다는 점이 이 생일 역설의 골자가 되는 내용이다. 생일은 불과 365가지의 경우의 수를 가진다.하지만 해시 함수의 영역에서는 2126 같은 엄청난 크기의 경우의 수를 갖게 되는데,이 안에서 n개의 임의의 서로 다른 데이터를 모아 중복되는 경우를 찾는 일은 실로 엄청난 컴퓨팅 비용이 필요하게 될 것이고 이는 경제적인 비용 문제로 이어질 것이다.(충돌쌍을 찾는다고 한다, 위에서 언급한 생일찾기와 닮아있다) 하지만 이 생일역설이 해시함수의 충돌쌍을 찾는 일에도 적용된다면 생각보다 적은 비용을 가지고도 충돌쌍을 찾는 일을 할 수 있을 것이다. 실제로 충돌쌍을 찾는 확률을 50%로 맞추면 2(n/2) 의 표본만 있으면 된다고 한다. 출력값의 길이가 210(1024) 라는 암호화 해시함수가 있다고 가정했을 때, 25(32)회의 무차별 대입을 통해 무려 50%의 확률로 충돌쌍을 찾아낼 수 있게되는 것이다. 경제성이 없어 포기할 수도 있었던 일을 생일 역설을 통해 다시 경제성이 있는 일로 판단할 수 있게 된 것이다. 그럼에도 불구하고확률적으로 n 비트의 출력값을 가지는 해시함수의 경우 2(n/2) 가지의 입력값을 조사할 경우 충돌쌍을 발견할 확률이 50% 정도가 된다고 했다. (엄밀히 말하면 이보다 조금 더 많은 가짓수가 필요) 128bit의 출력값을 가지는 MD5의 경우 약 264 의 서로 다른 데이터를 만들어 무차별 대입하는 공격을 시도하면 50%의 확률로 1개 이상의 충돌쌍을 발견할 수 있다는 이야기이다. 264 가 얼마나 많은 경우의 수인지 짐작 어려울 것 같아 이를 10진수로 표현하면 아래와 같음을 참고하기 바란다. 18,446,744,073,709,551,617 개의 경우의 수를 가진다. 차수가 1씩 늘어날 때 위 숫자에 곱하기 2씩 해야되는 것이다. 당연하게도 출력값의 길이가 길어질 수록 경우의 수는 무차별적으로 증가한다. 필자가 위 생일 역설을 참고해 n개의 데이터가 m종류의 해시값에 대해 하나 이상의 중복값을 가질 확률을 계산해 보았더니, 128bit의 출력값을 가지는 해시함수의 경우 백억번이라는 어마무시한 분량의 무차별 대입 공격법을 시도해도 그 확률은 0에 수렴했다. (파이썬으로 구현해 pypy3로 돌렸다. 구현내용은 너무 단순무식 + 허접하여 차마 공개하지 못 하겠다 ㅠㅠ) 64bit의 출력값을 가지는 해시함수의 경우에도 일억번의 무차별 대입을 가정했을 때, 그 확률은 약 0.00027101407375584863 로 계산되었다. 앞서서 구글에서 SHA1 의 충돌쌍을 발견한 경우를 간단히 링크로 소개했는데, 그 결과를 도출해내는데 있어 약 9경번의 연산이 필요했으며, 수억원의 가치에 상응하는 경제적 비용이 필요했다고 한다. (SHA1은 160bit의 결과값을 가진다. 가성비가 0에 수렴한다는 이야기) 이러한 이유로 전문가들이 충돌쌍이 하나가 발견되었던 어쨌던 실제 응용 환경에 적용할만한 공격은 발견되지 않았다..라고 하는 것 같다. 고로, 일상적인 경우.. 그러니까 뭐 인덱스로 사용한다거나 체크섬 생성 용도로 이용하는데 있어서는 대충 SHA1 이상 아무 해시함수나 사용해도 전혀 무리가 없다는 이야기 정도로 결론 지으면 될 것 같다. 종류와 선택우선 보안성을 고려한 선택을 할 수 있다. 나와 사용자의 암호를 암호화하는데 사용할 해시함수는 앞으로도 우리의 소중한 암호들을 오랜 기간 지켜줄 수 있는 녀석으로 고르는 것이 현명할 것이기 때문이다. 앞서 설명한 MD5 함수는 매우 취약한 함수로 분류되어 해시테이블의 인덱스로 사용하거나 파일의 Checksum 생성 등의 한정된 용도를 제외한 사용자 암호 보존 용도의 사용을 권하지 않고 있다. (물론 비밀번호 생성이나 변경시 임의의 난수값을 붙여서 함께 해싱하는 방법으로 Rainbow attack 등 공격을 예방할 수 있기도 하다.입력값 A에 별도의 의미없는 난수값 @ 를 붙여서 해싱을 하면 A일 때와는 전혀 다른 결과값이 나온다. 이를 소금치기(Adding Salt) 라고 하고 위 경우에서 @를 소금(Salt) 이라고 한다.이 때 이 난수값은 해싱된 비밀번호와 마찬가지로 별도 보관된다.) 또한, 해시함수는 그 용도와 사용방법에 따라서도 서로 다른 것을 선택할 수 있다. 완벽에 가까운 역상저항성과 충돌저항성이 필요하지 않으며 단순 파일 체크섬 생성 등의 용도로만 필요한 경우 MD5나 SHA-1같은 것을 선택할 수도 있고, 무차별 대입공격 등을 예방하기 위해 한 번의 연산에 다소간의 시간이 소요되는 함수를 일부러 선택할 수도 있으며,(0.2초의 시간이 걸린다고 했을 때 사람 입장에서는 찰나의 순간일지 몰라도 수많은 경우의 수를 반복해서 대입해야 하는 공격 프로그램 입장에서는 엄청난 시간적 자원의 소모를 불러 일으킨다.) 한번에 많은 양의 해시값을 만들어야 내는 경우 혹은 하나의 입력값에 일부러 여러번의 재귀 연산을 해야되는 경우에는 속도가 빠른 함수를 골라야될 필요가 있다. 세상에는 다양한 종류의 암호화 해시 함수가 존재한다. 그중에서도 가장 대표적인 것은 단연 SHA(Secure Hash Algorithm) 함수군이며,SHA 함수군은 NSA(미국 국가 안보국)에서 SHA-0이 1993년에 처음 개발되었다. SHA함수군은 다시 또 세대별로 SHA-0, SHA-1, SHA-2, SHA-3 으로 나뉘고,SHA-2 함수군은 다시 다이제스트의 길이에 따라 SHA-256, SHA-512 등으로 나뉜다. SHA-256은 256bit의 다이제스트 길이를, SHA-512는 512bit의 다이제스트 길이를 갖는 함수로써 보통 다이제스트 길이가 길수록(출력값의 경우의 수가 많을수록) 암호화 함수로써 안정성이 높다고 본다. 잡설이 길었지만.. 결론은 용두사미..SHA2 함수군은 2002년에 개발되었으며 그냥 일반적으로 널리 사용된다. SHA-256 부터는 우리가 사용하는 입력값의 가짓수를 수억개 단위로 놓고 보아도, 충돌값이 나올 확률은 그냥 지구 대멸종을 야기할 소행성의 충돌 확률 보다도 더 낮다고 생각하면 되겠다. 결론적으로 일반적인 용도로는 그냥 SHA2 함수군을 사용하고, 보안에 정말 장기적인 관점에서 각별히 신경을 써야 하는 주체라면 SHA3 혹은 잘 설계된 자체 함수를 사용하면 된다. LSH 국산 해시 암호화 함수여담이지만, 국내에도 NSR이라는 기관에서 개발된 토종 국산신토불이 암호화 해시 함수가 있다. LSH(Lightweight Secure Hash) 자세한 구현 방법과 C, Java, Python 으로 작성된 소스코드도 제공하니 관심있으신 분들은 살펴보시면 좋을 것 같다. 향후 대한민국의 표준화된 해시 함수로써 자리매김할 가능성이 농후하다.","link":"/2019/10/26/ETC/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98%EC%97%90_%EB%8C%80%ED%95%98%EC%97%AC/"},{"title":"Find 사용법","text":"Find 유티리티에 대한 별도 정리자료","link":"/2019/10/26/Linux/Shell%20Commands/Find%20%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0/"},{"title":"grep 사용법","text":"정규표현식을 이용한 텍스트 검색 grep [Pattern] [Filename] 일반적인 사용법 [Filename] 에서 [Pattern] 를 찾는다 기본적으로 Basic regular expression을 사용한다 grep -i [Pattern] 대소문자를 무시한다. Ignore Case Basic regular expression 패턴에서 일부 메타문자를 일반 문자로 인식한다. ex : ? , + , { , | , (, ) \\ 를 앞에 붙여줘야 비로서 정규표현식 메타문자로 작동한다 ex : \\?, \\+, \\{ … 굳이 \\를 붙이고 싶지 않다면 아래의 -E 옵션 사용이 가능하다. -E 옵션과 -F 옵션의 한 쌍 grep -ie [Pattern] 두번째 인자를 정규식 표현으로만 취급한다 - 가 들어간 문자열을 검색할 때 용이하다 ex : grep –help | grep -e -e grep –help 문서에서 -e 옵션을 검색한다 grep -Ei [Extended Regular Expression] 확장된 정규표현식에선 메타문자를 굳이 이스케이프하지 않아도 된다. ex : grep –help | grep -Ei ‘\\s(-e|-f)’ grep -Fi ‘(t|f)est’ 정규식을 사용하지 않고 순수 문자열로 검색 egrep과 fgrep egrep 사용시 -E 옵션 생략이 가능하다. ex : grep –help | grep -Ei ‘\\s(-e|-f)’ ex : grep –help | egrep -i ‘\\s-(-e|-f)’ fgrep 사용시 -F 옵션 생략이 가능하다. 경로 내 파일검색 및 하위 경로 탐색 grep [Pattern] ./* 해당 폴더내 파일들을 검색함 grep *-r** [Pattern] ./** 하위 폴더의 파일들까지 모두 탐색함 줄에 대한 정보들 grep *-n** [Pattern] ./** 매칭되는 라인번호를 표시함 grep -c [Pattern] [Filename] 해당 패턴이 매칭되는 줄이 총 몇 줄인지 라인 수를 출력함. 파일 이름 관련 grep *-l*** 파일 이름만 출력함 grep *-h*** 파일 이름을 출력하지 않음 grep *-H*** 파일 이름을 출력함 grep -C[n] [Pattern] [Filename] 매칭된 라인 앞뒤로 n개 줄을 표시함. grep -m[n] [Pattern] [Filename] 파일 당 출력 라인수를 제한함. 저장된 패턴을 활용 grep -f [Filename] [Filename] -f 뒤의 [Filename] 의 내용을 패턴으로 활용해 검색한다.","link":"/2019/10/26/Linux/Shell%20Commands/Grep%20%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0/"},{"title":"사용자 관리","text":"사용자 관리에 대한 별도 정리자료 권한에 대하여소유주, 그룹, 그 외 사람들rwx 로 권한을 표기한다/etc/passwd 에 대하여/etc/shadow 에 대하여과거에는 /etc/passwd 파일에 직접 인코딩된 암호를 기록하여 사용했다. 이후 Shadow Suite의 적용으로 /etc/passwd에 직접 암호를 저장하지 않고,/etc/shadow 에 각 유저에 매칭되는 암호화된 암호와 암호에 관련된 다양한 설정들을 기록해 사용하는 형태로 변모하였다. 보통 /etc/passwd 는 644(rw-r-r)의 권한을 갖고,/etc/shadow는 600(rw-권한없음-권한없음)의 권한을 갖는다. /etc/shadow의 구조/etc/shadow 파일내에는 각 유저들의 암호화된 비밀번호 와 비밀번호에 관련된 설정값 들이 기록되어있다. test:$6$O71pCNwB$GnBKDEYulhNdk0QFEpuDX3Ge(중략 ...):18112:0:99999:7::: 각 필드 살펴보기콜론 : 을 구분자로 사용해 각 필드를 구분한다. 첫번째 - test /etc/passwd 에 기록된 유저명과 매칭이 된다. 두번째 - “$6$O71pCNwB$GnBKDEYulhNdk0QFEpuDX3Ge(중략 ...)“ 암호화된 Password 이다. (동어 반복 느낌이 나서 굳이 영단어를 썼다) 이 역시도 달러기호 $ 를 구분자로 사용해 다시 필드가 나뉜다. 첫번째 - 6 두번째 - O71pCNwB 세번째 - GnBKDEYulhNdk0QFEpuDX3Ge(중략 …) 세번째 - 18112 네번째 - 0 다섯번째 - 99999 여섯번째 - 7 해시함수부록-해시함수.md 를 참고할 것. 쓰고나서 투머치한 감이 없잖게 있어서 따로 항목을 새로 만들었습니다. 사족과도 같은 내용으로 필요한 분만 간단하게 참고하는 용도로 열람하시면 될 것 같습니다. 사용자 추가, 삭제, 수정사용자 추가하기사용자 삭제하기사용자 삭제시 오류 사례사용자 수정하기사용자 목록 확인패스워드 변경그룹 추가, 삭제, 수정그룹 목록 확인UID, GID","link":"/2019/10/26/Linux/Shell%20Commands/%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B4%80%EB%A6%AC/"},{"title":"리눅스 파일처리 커맨드","text":"파일들을 조회하고, 지우고, 잘라내고, 복사하고, 바로가기를 만든다 ls - List ls -a 숨김파일 포함해 전체 출력. ls -A -a 와 동일하되 .와 ..를 제외하고 출력. ls -l 리스트 형태로 출력. ls -l (기본값) 기본적으로 최종 수정시간을 표시한다 (Modified) ls -lc -l 옵션에서 시간을 최종 변경시간으로 표시 (Changed) ls -lu -l 옵션에서 시간을 최종 접근시간으로 표시 (Access) ls -h 파일크기를 KB, GB, MB 단위로 알아보기 쉽게 출력. (Human) ls - 정렬 관련 옵션 ls -t 시간순으로 정렬 ls -ct 파일을 최종 변경시간 기준으로 정렬 (Changed Time) ls -t (기본값) 파일을 최종 수정시간 기준으로 정렬 (Modified Time) ls -*ut* 파일을 최종 접근 시간 기준으로 정렬 (A**ccess Time) ls -S 파일 크기 순서대로 정렬 ls -r 역순으로 정렬 ls - 시간 표기방법 변경 ls -lh *–time-style=long-iso*** 2019-08-02 와 같은 형태로 출력. ls -lh *–time-style=’+%y/%m/%d %H:%M’*** 19/08/02 23:31 와 같은 형태로 출력. rm - Remove rm -r 디렉토리 삭제. (Recursive, 반복되는, 재귀적인)(Interactive, 반응형) rm \\.c* c 확장자 파일 다 삭제 mv - Move mv -b aa bb aa를 bb로 이동(변경)하는데 bb가 존재할 경우 bb의 백업파일을 생성한다. cp - Copy cp ./aa/\\ bb* ./aa 안의 모든 파일을 bb 폴더로 옮긴다. cp -p aa bb aa의 권한, 소유주 정보를 그대로 bb로 복사 rm mv cp 명령어의 -i -v -f 옵션에 대하여 -i : Interactive, 동작하기 전 사용자에게 재확인 -v : Verbose, 동작한 내용을 출력 -f : Force, 강제로 동작 mkdir - Make Directory mkdir -p ./aa/bb ./aa 경로가 없을 경우 오류가 출력되나, -p 옵션(Parents) 사용시 ./aa 생성 후 ./aa/bb 생성함. mkdir -m 777 ./aa -m 옵션을 사용해 생성할 디렉토리의 권한을 지정. ln - Link ln aa bb ab라는 이름의 aa를 향한 하드 링크를 생성한다. ln -s aa ab ab라는 이름의 aa를 향한 심볼릭 링크를 생성한다. 하드링크와 심볼릭 링크링크에는 하드링크와 심볼릭링크 두 종류가 있다. 하드 링크 Hard Link원본 파일과 동일한 Inode에 링크한다.원본 파일이 삭제되어도 해당 Inode에 연결된 하드링크 파일이 있다면,(해당 파일의 Inode 상 링크수가 0이 아니라면)해당 파일의 Inode는 Free가 되지 않고하드링크로 해당 파일에 지속 접근이 가능하다.하드링크 파일과 원본 파일은 Inumber가 동일하다.동일한 Inode를 참조하므로 하드링크 생성으로 인해 디스크 공간이 줄어들지 않는다 심볼릭 링크 Symbolic Link새로운 Inode를 생성하고,해당 Inode에는 원본 파일의 주소가 기록되어 있다.당연히, 원본파일이 삭제되거나 경로가 달라지면 더 이상 원본 파일의 내용에 접근이 불가하다.","link":"/2019/10/26/Linux/Shell%20Commands/%ED%8C%8C%EC%9D%BC%EC%B2%98%EB%A6%AC/"},{"title":"시스템 조작","text":"시스템 조작 및 간단한 시스템 정보를 조회하는 방법 shutdown시스템을 종료하거나 재부팅한다 shutdown -h now 즉시 시스템 종료 shutdown -h 15 15분 뒤 시스템 종료 shutdown -h 22:00 22:00 에 셧다운 예약 shutdown -c 예약된 셧다운 취소 shutdown -k +15 15분 뒤 종료 예정이라고 전 사용자에게 경고 shutdown -r 재부팅 w, who, whoami, users접속중인 사용자들에 대한 정보를 조회한다 w 현재 접속한 사용자 목록 출력 who 위와 동일 who -b 시스템 부팅시간 출력 UTC로 표기가 되므로, 한국 시간을 알고싶다면 -9시간을 계산해야 된다. UTC(Universal Time + Coordinated, 협정세계시간) 한국은 UTC+9 (UTC에 9시간을 더함) 를 사용한다. whoami 현재 로그인된 호스트명 출력 users 접속된 사용자 리스트를 나열 idid에 관련된 조회 동작을 실시한다 id -un 현재 호스트명 출력 id 1000 -un uid 1000의 호스트명 출력 id -u 현재 로그인된 계정의 uid 출력 finger특정 유저의 이름, 메일, 로그인시간 등의 정보를 확인한다 finger -s 현재 로그인된 계정의 정보를 출력 finger -s username username으로 지정한 유저의 정보를 출력 md5sum 특정 파일의 md5 체크섬을 확인 md5sum filename md5 체크섬을 출력. df - Disk Free디스크 사용정보를 출력 df *-text4 -hT*** -h 옵션으로 읽기 쉬운 단위로 출력 -T 옵션으로 파일시스템 정보를 출력 -t[type] 옵션으로 해당 파일시스템의 파티션만 필터링 du - Disk Usage디스크 사용량을 표시한다 du *-hs*** -hs -&gt; Human Readable, Short 사람이 읽을 수 있게 요약해서 총량만 출력 dur *-hsS*** -S 하위 파일 제외 순수 현재 폴더만의 디스크 사용량 표시 free - Memory Usage메모리 사용량을 표시한다 free *-hs1*** -s1 1초에 한 번씩 사용현황을 append -t 총 사용량 행을 가장 아래에 출력","link":"/2019/10/26/Linux/Shell%20Commands/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A1%B0%EC%9E%91/"},{"title":"리눅스 텍스트처리 커맨드","text":"텍스트 처리에 관련된 기능들 cat 파일의 내용을 출력합니다 cat [Filename] [Filename] 의 내용을 출력합니다 cat [Filename1] [Filename2] … 나열된 파일들을 연이어 출력합니다 cat -n [Filename] 줄 번호를 붙여서 출력합니다 cat을 입력도구로 사용하기 옵션 없이 cat 만을 사용할 경우 입력 도구로 사용이 가능합니다 ex : cat &gt; [Filename] 이후 텍스트를 입력하고 엔터를 치면 해당 파일에 기록이 되기 시작합니다. head - 앞 쪽만 보여줘 cat /etc/passwd | head -n 50 위에서 50 라인만 출력. cat /etc/passwd | head -n -50 아래에서 50 라인 빼고 전부 출력. tail - 아래 쪽 보여줘 로그 조회하는 용도로 많이 사용. tail /etc/passwd -n 50 밑에서 50줄만 보여줘. tail /etc/passwd -F 추가되는 내용을 지속 팔로우하여 출력. 파일이 삭제되었다 다시 생성되어도 re-open하여 계속 팔로우함. -f 옵션의 경우 파일 재생성시 팔로우 안 함. wc - Word Count wc /etc/passwd 줄수 / 단어수 / 바이트 카운트 출력. wc /etc/passwd -l 라인수만 출력함. wc \\.c -l* c파일의 모든 라인수 출력. wc /etc/passwd -l | awk ‘{ print $1 }’ 라인수만 출력함. nl - Number Line nl /etc/passwd nl /etc/passwd -ba 공백 라인에도 줄 번호를 출력. nl /etc/passwd -v 10 번호가 10번부터 시작함. sort - 파일을 정렬 cat /etc/passwd | sort cat /etc/passwd | sort -r -r 리버스. 거꾸로 뒤집는다. cat /etc/passwd | sort -t: -k1,1 -k2,2 -t 옵션으로 구분자를 정하고, -k1,1 -k2,2 옵션으로 첫번째 칼럼과 두번째 칼럼을 기준으로 잡고 정렬함. uniq - 중복 제거 cat /etc/passwd | awk -F: ‘{print $1}’ | uniq -i | sort -k 2,2 | nl 유저 이름을 중복없이 알파벳 순으로 정렬. cat /etc/passwd | uniq -i -d -d 옵션은 중복된 값만 출력한다. cat /etc/passwd | uniq -i -u -u 옵션은 중복되지 않은 유일한 값만 출력한다. cut - 잘라내기 cat /etc/passwd cut -d’:’ -f 1,3","link":"/2019/10/26/Linux/Shell%20Commands/%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%B2%98%EB%A6%AC/"}],"tags":[{"name":"단락평가","slug":"단락평가","link":"/tags/%EB%8B%A8%EB%9D%BD%ED%8F%89%EA%B0%80/"},{"name":"지름길평가","slug":"지름길평가","link":"/tags/%EC%A7%80%EB%A6%84%EA%B8%B8%ED%8F%89%EA%B0%80/"},{"name":"short-circuit evaluation","slug":"short-circuit-evaluation","link":"/tags/short-circuit-evaluation/"},{"name":"javscript","slug":"javscript","link":"/tags/javscript/"},{"name":"해시함수","slug":"해시함수","link":"/tags/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell Commands","slug":"Shell-Commands","link":"/tags/Shell-Commands/"}],"categories":[{"name":"JavsScript","slug":"JavsScript","link":"/categories/JavsScript/"},{"name":"ETC","slug":"ETC","link":"/categories/ETC/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}